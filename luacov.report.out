==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/api.lua
==============================================================================
  11 local curl = require("plenary.curl")
  11 local pulse = require("maorun.code-stats.pulse")
  11 local cs_config = require("maorun.code-stats.config")
  11 local logging = require("maorun.code-stats.logging")

  11 local error_message = ""
  11 local is_vim_leaving = false

     local function requestToApi(body)
***0 	local url = cs_config.config.api_url
***0 	local full_url = url .. "api/my/pulses/"

***0 	logging.debug("Attempting API request to " .. full_url)

***0 	return curl.request({
     		url = full_url,
     		method = "POST",
***0 		headers = {
     			["X-API-Token"] = cs_config.config.api_key,
     			["Content-Type"] = "application/json",
     			["Accept"] = "application/json",
     		},
     		body = body,
     		on_error = function(data)
***0 			local error_details = data.message or "Unknown network error"
***0 			error_message = "Unable to sync with Code::Stats server: " .. error_details
***0 			logging.log_api_request(full_url, "POST", false, error_details)

     			-- If we're leaving vim and there's an error, persist the XP data
***0 			if is_vim_leaving then
***0 				pulse.save()
***0 				logging.warn("XP data persisted due to API error during vim exit")
     			end
     		end,
     		callback = function(response)
***0 			if response.status >= 200 and response.status < 300 then
***0 				error_message = ""
***0 				pulse.reset()
***0 				logging.log_api_request(full_url, "POST", true)
***0 				logging.info("XP data successfully sent to Code::Stats")
     			else
***0 				error_message = "Code::Stats server error (HTTP " .. response.status .. ")"
***0 				logging.log_api_request(full_url, "POST", false, "HTTP " .. response.status)
     			end
     		end,
     	})
     end

     local function pulseSend()
***0 	logging.debug("Starting pulse send operation")

     	-- Check if config is initialized by checking essential string fields
***0 	local config_values = {
***0 		cs_config.config.status_prefix,
***0 		cs_config.config.api_url,
***0 		cs_config.config.api_key,
     	}
***0 	if string.len(table.concat(config_values)) == 0 then
***0 		error_message = "Code::Stats plugin not properly configured"
***0 		logging.error("Plugin configuration incomplete - missing essential settings")
***0 		return
     	end

***0 	local url = cs_config.config.api_url
***0 	if string.len(url) == 0 then
***0 		error_message = "Code::Stats API URL not configured"
***0 		logging.error("Missing API URL configuration")
***0 		return
     	end

***0 	if string.len(cs_config.config.api_key) == 0 then
***0 		error_message = "Code::Stats API key not configured"
***0 		logging.error("Missing API key configuration")
***0 		return
     	end

     	-- If there was an error message set by previous checks, clear it if we proceed
***0 	error_message = ""

***0 	local languages = vim.fn.map(pulse.xps, function(language, xp)
***0 		if xp > 0 then
***0 			return '{"language": "' .. language .. '", "xp": ' .. xp .. "}"
     		else
***0 			return ""
     		end
     	end)

***0 	local xps = table.concat(vim.tbl_values(languages), ",")

***0 	if string.len(xps) > 0 then
***0 		local timestamp = os.date("%Y-%m-%dT%X%z")
***0 		local payload = '{ "coded_at": "' .. timestamp .. '", "xps": [ ' .. xps .. " ] }"
***0 		logging.info("Sending XP data: " .. xps)
***0 		requestToApi(payload)
***0 	elseif is_vim_leaving then
     		-- If we're leaving vim but have no XP to send, still clean up any persistence file
***0 		pulse.reset()
***0 		logging.info("No XP to send on vim exit, cleaning up persistence")
     	else
***0 		logging.debug("No XP data to send")
     	end
     end

     local function pulseSendOnExit()
***0 	logging.info("Performing final pulse send on vim exit")
***0 	is_vim_leaving = true
***0 	pulseSend()
***0 	is_vim_leaving = false
     end

     local function get_error()
   8 	return error_message
     end

     local function getProfile(callback)
   2 	logging.debug("Starting profile request operation")

     	-- Check if config is initialized by checking essential string fields
   2 	local config_values = {
   2 		cs_config.config.status_prefix,
   2 		cs_config.config.api_url,
   2 		cs_config.config.api_key,
     	}
   4 	if string.len(table.concat(config_values)) == 0 then
***0 		local error_msg = "Code::Stats plugin not properly configured"
***0 		logging.error("Plugin configuration incomplete - missing essential settings")
***0 		if callback then
***0 			callback(nil, error_msg)
     		end
***0 		return
     	end

   2 	local url = cs_config.config.api_url
   4 	if string.len(url) == 0 then
***0 		local error_msg = "Code::Stats API URL not configured"
***0 		logging.error("Missing API URL configuration")
***0 		if callback then
***0 			callback(nil, error_msg)
     		end
***0 		return
     	end

   4 	if string.len(cs_config.config.api_key) == 0 then
***0 		local error_msg = "Code::Stats API key not configured"
***0 		logging.error("Missing API key configuration")
***0 		if callback then
***0 			callback(nil, error_msg)
     		end
***0 		return
     	end

   2 	local full_url = url .. "api/my/profile"
   2 	logging.debug("Attempting profile API request to " .. full_url)

   2 	return curl.request({
   2 		url = full_url,
     		method = "GET",
   2 		headers = {
   2 			["X-API-Token"] = cs_config.config.api_key,
     			["Accept"] = "application/json",
   2 		},
     		on_error = function(data)
   1 			local error_details = data.message or "Unknown network error"
   1 			local error_msg = "Unable to retrieve profile from Code::Stats server: " .. error_details
   1 			logging.log_api_request(full_url, "GET", false, error_details)
   1 			if callback then
   1 				callback(nil, error_msg)
     			end
     		end,
     		callback = function(response)
   1 			if response.status >= 200 and response.status < 300 then
   1 				logging.log_api_request(full_url, "GET", true)
   1 				logging.info("Profile data successfully retrieved from Code::Stats")
   1 				if callback then
   1 					callback(response.body, nil)
     				end
     			else
***0 				local error_msg = "Code::Stats server error (HTTP " .. response.status .. ")"
***0 				logging.log_api_request(full_url, "GET", false, "HTTP " .. response.status)
***0 				if callback then
***0 					callback(nil, error_msg)
     				end
     			end
     		end,
   2 	})
     end

  11 return {
  11 	pulseSend = pulseSend,
  11 	pulseSendOnExit = pulseSendOnExit,
  11 	requestToApi = requestToApi,
  11 	get_error = get_error,
  11 	getProfile = getProfile,
  11 }

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/config.lua
==============================================================================
  23 local defaults = {
     	status_prefix = "C:S ",
     	api_url = "https://codestats.net/",
     	api_key = "",
  23 	ignored_filetypes = {},
     	enhanced_statusline = false, -- Show XP, level, and progress in statusline
     	statusline_format = "%s%d (%d%% to L%d)", -- Format: prefix, xp, progress%, next_level
  23 	notifications = {
     		enabled = true, -- Enable all notifications
  23 		level_up = {
     			enabled = true, -- Enable level-up notifications
     			message = "ðŸŽ‰ Level Up! %s reached level %d!", -- Format: language, new_level
  23 		},
  23 	},
  23 	logging = {
     		enabled = false,
     		level = "INFO", -- ERROR, WARN, INFO, DEBUG
     		file_path = nil, -- Will default to vim.fn.stdpath("data") .. "/code-stats.log" if not set
  23 	},
     }
  23 local config = defaults

  23 local logging = require("maorun.code-stats.logging")
  23 local notifications = require("maorun.code-stats.notifications")

  23 local M = {
  46 	config = vim.deepcopy(defaults),
     }

  23 function M.setup(user_config)
  25 	local globalConfig = {}
  25 	if vim.g.codestats_api_key then
***0 		globalConfig.api_key = vim.g.codestats_api_key
     	end
  50 	config = vim.tbl_deep_extend("force", defaults, user_config or {}, globalConfig)
  25 	M.config = config

     	-- Configure logging based on config
  25 	local log_config = {
  25 		enabled = config.logging.enabled,
  25 		file_path = config.logging.file_path,
     	}

     	-- Convert string level to number
  25 	if type(config.logging.level) == "string" then
  25 		local level_map = {
  25 			ERROR = logging.levels.ERROR,
  25 			WARN = logging.levels.WARN,
  25 			INFO = logging.levels.INFO,
  25 			DEBUG = logging.levels.DEBUG,
     		}
  25 		log_config.level = level_map[config.logging.level] or logging.levels.INFO
     	else
***0 		log_config.level = config.logging.level
     	end

  25 	logging.setup(log_config)
  25 	logging.log_config("Plugin configured with logging " .. (config.logging.enabled and "enabled" or "disabled"))

     	-- Setup notifications with the config
  25 	notifications.setup(config)

  25 	return config
     end

  23 return M

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/events.lua
==============================================================================
   2 local lang_detection = require("maorun.code-stats.language-detection")
   2 local logging = require("maorun.code-stats.logging")

     local function setup_autocommands(add_xp_callback, pulse_send_callback, pulse_send_on_exit_callback)
  10 	logging.log_init("Setting up autocommands for XP tracking")
  10 	local group = vim.api.nvim_create_augroup("codestats_track", { clear = true })

  20 	vim.api.nvim_create_autocmd({ "InsertCharPre", "TextChanged" }, {
  10 		group = group,
     		pattern = "*",
     		callback = function()
***0 			if add_xp_callback then
***0 				local detected_lang = lang_detection.detect_language()
***0 				add_xp_callback(detected_lang)
     			end
     		end,
     	})

  20 	vim.api.nvim_create_autocmd("VimLeavePre", {
  10 		group = group,
     		pattern = "*",
     		callback = function()
***0 			if pulse_send_on_exit_callback then
***0 				pulse_send_on_exit_callback()
     			end
     		end,
     	})

  20 	vim.api.nvim_create_autocmd({ "BufWrite", "BufLeave" }, {
  10 		group = group,
     		pattern = "*",
     		callback = function()
***0 			if pulse_send_callback then
***0 				pulse_send_callback()
     			end
     		end,
     	})

  10 	logging.log_init("Autocommands configured successfully")
     end

   2 return {
   2 	setup_autocommands = setup_autocommands,
   2 }

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/init.lua
==============================================================================
  10 local pulse = require("maorun.code-stats.pulse")
  10 local cs_config = require("maorun.code-stats.config")
  10 local api = require("maorun.code-stats.api")
  10 local events = require("maorun.code-stats.events")
  10 local lang_detection = require("maorun.code-stats.language-detection")
  10 local logging = require("maorun.code-stats.logging")
***0 local statistics = require("maorun.code-stats.statistics")

     -- Load any persisted XP data from previous sessions
  10 logging.log_init("Loading persisted XP data")
***0 pulse.load()

     -- The local 'error' variable has been removed. Errors are now primarily managed in api.lua.

     local function currentXp()
     	-- currentXp now relies on M.getError() which gets its value from api.get_error()
***0 	if string.len(api.get_error()) > 0 then
***0 		return cs_config.config.status_prefix .. "ERR"
     	end

***0 	local detected_lang = lang_detection.detect_language()

     	-- If enhanced statusline is enabled, show XP, level, and progress
***0 	if cs_config.config.enhanced_statusline then
***0 		local xp = pulse.getXp(detected_lang)
***0 		local level = pulse.getLevel(detected_lang)
***0 		local progress = pulse.getProgressToNextLevel(detected_lang)
***0 		local next_level = level + 1

***0 		return string.format(
***0 			cs_config.config.statusline_format,
***0 			cs_config.config.status_prefix,
     			xp,
     			progress,
     			next_level
     		)
     	else
     		-- Default behavior: just show XP
***0 		return cs_config.config.status_prefix .. pulse.getXp(detected_lang)
     	end
     end

     -- Enhanced statusline function that can be called directly
     local function currentXpEnhanced()
***0 	if string.len(api.get_error()) > 0 then
***0 		return cs_config.config.status_prefix .. "ERR"
     	end

***0 	local detected_lang = lang_detection.detect_language()
***0 	local xp = pulse.getXp(detected_lang)
***0 	local level = pulse.getLevel(detected_lang)
***0 	local progress = pulse.getProgressToNextLevel(detected_lang)
***0 	local next_level = level + 1

  10 	return string.format(cs_config.config.statusline_format, cs_config.config.status_prefix, xp, progress, next_level)
     end

     -- Get formatted XP information for the current language
     local function getCurrentLanguageXP()
***0 	if string.len(api.get_error()) > 0 then
***0 		return "Error: " .. api.get_error()
     	end

   1 	local detected_lang = lang_detection.detect_language()
   1 	local xp = pulse.getXp(detected_lang)
  10 	return string.format("Language: %s, XP: %d", detected_lang or "unknown", xp)
     end

     -- Get formatted XP information for all tracked languages
     local function getAllLanguagesXP()
***0 	if string.len(api.get_error()) > 0 then
***0 		return "Error: " .. api.get_error()
     	end

   3 	local result = "Tracked languages and XP:\n"
***0 	local languages = {}

     	-- Collect all languages with XP > 0
   6 	for lang, xp in pairs(pulse.xps) do
   6 		if xp > 0 then
***0 			table.insert(languages, { lang = lang, xp = xp })
     		end
     	end

     	-- Sort by XP descending
   6 	table.sort(languages, function(a, b)
   3 		return a.xp > b.xp
     	end)

   1 	if #languages == 0 then
***0 		result = result .. "  No XP tracked yet"
     	else
   6 		for _, entry in ipairs(languages) do
***0 			result = result .. string.format("  %s: %d XP\n", entry.lang, entry.xp)
     		end
     		-- Remove trailing newline
***0 		result = result:sub(1, -2)
     	end

  10 	return result
     end

     -- Get formatted XP information for a specific language
     local function getLanguageXP(language)
***0 	if string.len(api.get_error()) > 0 then
***0 		return "Error: " .. api.get_error()
     	end

   2 	if not language or language == "" then
***0 		return "Error: No language specified"
     	end

   2 	local xp = pulse.getXp(language)
  10 	return string.format("Language: %s, XP: %d", language, xp)
     end

***0 local M = {}

***0 function M.add(filetype)
     	-- Check if filetype is in ignored list
   8 	for _, ignored_type in ipairs(cs_config.config.ignored_filetypes) do
   3 		if filetype == ignored_type then
   3 			logging.debug("Skipping XP for ignored filetype: " .. filetype)
***0 			return -- Don't add XP for ignored filetypes
     		end
     	end
  25 	pulse.addXp(filetype, 1)
     end

  10 M.setup = cs_config.setup
  10 M.pulseSend = api.pulseSend
  10 M.currentXp = currentXp
***0 M.currentXpEnhanced = currentXpEnhanced
     M.getError = function()
  10 	return api.get_error()
     end

     -- Public functions for user commands
  10 M.getCurrentLanguageXP = getCurrentLanguageXP
  10 M.getAllLanguagesXP = getAllLanguagesXP
***0 M.getLanguageXP = getLanguageXP

     -- Setup autocommands by passing the local add function, api.pulseSend, and api.pulseSendOnExit
***0 events.setup_autocommands(M.add, M.pulseSend, api.pulseSendOnExit)

     -- Create user commands
***0 vim.api.nvim_create_user_command("CodeStatsXP", function()
***0 	local info = getCurrentLanguageXP()
***0 	local error_msg = api.get_error()

***0 	if string.len(error_msg) > 0 then
***0 		vim.notify("Code::Stats Error: " .. error_msg, vim.log.levels.ERROR, { title = "Code::Stats" })
***0 		logging.error("User command CodeStatsXP failed: " .. error_msg)
     	else
***0 		vim.notify(info, vim.log.levels.INFO, { title = "Code::Stats" })
***0 		logging.debug("User command CodeStatsXP executed successfully")
     	end
***0 end, { desc = "Show XP for current language" })

***0 vim.api.nvim_create_user_command("CodeStatsAll", function()
***0 	local info = getAllLanguagesXP()
***0 	local error_msg = api.get_error()

***0 	if string.len(error_msg) > 0 then
***0 		vim.notify("Code::Stats Error: " .. error_msg, vim.log.levels.ERROR, { title = "Code::Stats" })
***0 		logging.error("User command CodeStatsAll failed: " .. error_msg)
     	else
***0 		vim.notify(info, vim.log.levels.INFO, { title = "Code::Stats" })
***0 		logging.debug("User command CodeStatsAll executed successfully")
     	end
***0 end, { desc = "Show XP for all tracked languages" })

***0 vim.api.nvim_create_user_command("CodeStatsLang", function(opts)
***0 	local info = getLanguageXP(opts.args)
***0 	local error_msg = api.get_error()

***0 	if string.len(error_msg) > 0 then
***0 		vim.notify("Code::Stats Error: " .. error_msg, vim.log.levels.ERROR, { title = "Code::Stats" })
***0 		logging.error("User command CodeStatsLang failed: " .. error_msg)
     	else
***0 		vim.notify(info, vim.log.levels.INFO, { title = "Code::Stats" })
***0 		logging.debug("User command CodeStatsLang executed for language: " .. (opts.args or "unknown"))
     	end
***0 end, {
     	nargs = 1,
     	desc = "Show XP for specific language",
     	complete = function()
     		-- Return list of tracked languages for completion
***0 		local languages = {}
***0 		for lang, xp in pairs(pulse.xps) do
***0 			if xp > 0 then
***0 				table.insert(languages, lang)
     			end
     		end
***0 		table.sort(languages)
  10 		return languages
     	end,
     })

     -- Add user command for managing logging
***0 vim.api.nvim_create_user_command("CodeStatsLog", function(opts)
***0 	local action = opts.args or ""

***0 	if action == "clear" then
***0 		logging.clear_log()
***0 		vim.notify("Code::Stats log file cleared", vim.log.levels.INFO, { title = "Code::Stats" })
***0 	elseif action == "path" then
***0 		local log_path = logging.get_log_file()
***0 		if log_path and logging.is_enabled() then
***0 			vim.notify("Log file: " .. log_path, vim.log.levels.INFO, { title = "Code::Stats" })
     		else
***0 			vim.notify("Logging is disabled", vim.log.levels.WARN, { title = "Code::Stats" })
     		end
***0 	elseif action == "status" then
***0 		local status = logging.is_enabled() and "enabled" or "disabled"
***0 		local log_path = logging.get_log_file() or "not set"
***0 		vim.notify(
***0 			"Logging is " .. status .. "\nLog file: " .. log_path,
***0 			vim.log.levels.INFO,
***0 			{ title = "Code::Stats" }
     		)
     	else
***0 		vim.notify("Usage: :CodeStatsLog [clear|path|status]", vim.log.levels.INFO, { title = "Code::Stats" })
     	end
***0 end, {
     	nargs = "?",
     	desc = "Manage Code::Stats logging (clear|path|status)",
     	complete = function()
  10 		return { "clear", "path", "status" }
     	end,
     })

     -- Add user command for manual XP synchronization
***0 vim.api.nvim_create_user_command("CodeStatsXpSend", function()
***0 	local error_msg = api.get_error()

     	-- Clear any previous error before sending
***0 	api.pulseSend()

     	-- Check for errors after sending
***0 	local new_error_msg = api.get_error()

***0 	if string.len(new_error_msg) > 0 then
***0 		vim.notify("Code::Stats Error: " .. new_error_msg, vim.log.levels.ERROR, { title = "Code::Stats" })
***0 		logging.error("User command CodeStatsXpSend failed: " .. new_error_msg)
     	else
***0 		vim.notify("XP data successfully sent to Code::Stats", vim.log.levels.INFO, { title = "Code::Stats" })
***0 		logging.debug("User command CodeStatsXpSend executed successfully")
     	end
***0 end, { desc = "Send all pending XP to Code::Stats immediately" })

     -- Add user command for profile display
***0 vim.api.nvim_create_user_command("CodeStatsProfile", function()
***0 	api.getProfile(function(profile_data, error_msg)
***0 		if error_msg then
***0 			vim.notify("Code::Stats Error: " .. error_msg, vim.log.levels.ERROR, { title = "Code::Stats" })
***0 			logging.error("User command CodeStatsProfile failed: " .. error_msg)
***0 		elseif profile_data then
     			-- Parse the JSON response
***0 			local ok, profile = pcall(vim.fn.json_decode, profile_data)
***0 			if not ok then
***0 				vim.notify(
     					"Code::Stats Error: Invalid profile data received",
***0 					vim.log.levels.ERROR,
***0 					{ title = "Code::Stats" }
     				)
***0 				logging.error("User command CodeStatsProfile failed: JSON decode error")
***0 				return
     			end

     			-- Format and display profile information
***0 			local info = "Code::Stats Profile:\n"
***0 			if profile.user then
***0 				info = info .. "User: " .. (profile.user.username or "Unknown") .. "\n"
     			end
***0 			if profile.total_xp then
***0 				info = info .. "Total XP: " .. profile.total_xp .. "\n"
     			end
***0 			if profile.level then
***0 				info = info .. "Level: " .. profile.level .. "\n"
     			end
***0 			if profile.languages and type(profile.languages) == "table" then
***0 				info = info .. "Top Languages:\n"
     				-- Show top 5 languages if available
***0 				local count = 0
***0 				for lang, xp in pairs(profile.languages) do
***0 					if count >= 5 then
     						break
     					end
***0 					info = info .. "  " .. lang .. ": " .. xp .. " XP\n"
***0 					count = count + 1
     				end
     			end

***0 			vim.notify(info, vim.log.levels.INFO, { title = "Code::Stats" })
***0 			logging.debug("User command CodeStatsProfile executed successfully")
     		else
***0 			vim.notify("Code::Stats Error: No profile data received", vim.log.levels.ERROR, { title = "Code::Stats" })
***0 			logging.error("User command CodeStatsProfile failed: No data received")
     		end
     	end)
***0 end, { desc = "Show Code::Stats profile information" })

     -- Add user command for daily statistics
***0 vim.api.nvim_create_user_command("CodeStatsDaily", function(opts)
  10 	local date = opts.args and opts.args ~= "" and opts.args or nil
***0 	local daily_stats = statistics.get_daily_stats(date)
***0 	local formatted = statistics.format_daily_stats(daily_stats)

***0 	vim.notify(formatted, vim.log.levels.INFO, { title = "Code::Stats" })
***0 	logging.debug("User command CodeStatsDaily executed for date: " .. (date or "today"))
***0 end, {
     	nargs = "?",
     	desc = "Show daily XP statistics (optional: YYYY-MM-DD)",
     })

     -- Add user command for weekly statistics
***0 vim.api.nvim_create_user_command("CodeStatsWeekly", function(opts)
***0 	local date = opts.args and opts.args ~= "" and opts.args or nil
***0 	local weekly_stats = statistics.get_weekly_stats(date)
***0 	local formatted = statistics.format_weekly_stats(weekly_stats)

***0 	vim.notify(formatted, vim.log.levels.INFO, { title = "Code::Stats" })
***0 	logging.debug("User command CodeStatsWeekly executed for date: " .. (date or "current week"))
***0 end, {
     	nargs = "?",
     	desc = "Show weekly XP statistics (optional: YYYY-MM-DD)",
     })

     -- Add user command for monthly statistics
***0 vim.api.nvim_create_user_command("CodeStatsMonthly", function(opts)
***0 	local year, month = nil, nil
***0 	if opts.args and opts.args ~= "" then
     		-- Parse YYYY-MM format
***0 		local parts = vim.split(opts.args, "-")
***0 		if #parts >= 1 then
***0 			year = tonumber(parts[1])
     		end
***0 		if #parts >= 2 then
***0 			month = tonumber(parts[2])
     		end
     	end

***0 	local monthly_stats = statistics.get_monthly_stats(year, month)
***0 	local formatted = statistics.format_monthly_stats(monthly_stats)

***0 	vim.notify(formatted, vim.log.levels.INFO, { title = "Code::Stats" })
***0 	logging.debug("User command CodeStatsMonthly executed for: " .. (opts.args or "current month"))
***0 end, {
     	nargs = "?",
     	desc = "Show monthly XP statistics (optional: YYYY-MM)",
     })

***0 logging.log_init("User commands created successfully")
***0 logging.log_init("Code::Stats plugin initialization complete")

***0 return M

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/language-detection.lua
==============================================================================
  11 local M = {}

     -- Get the current cursor position
     local function get_cursor_position()
   5 	local cursor = vim.api.nvim_win_get_cursor(0)
   5 	return cursor[1] - 1, cursor[2] -- Convert to 0-indexed for treesitter
     end

     -- Attempt to detect language using treesitter language injection
     local function detect_language_at_cursor()
   7 	local base_filetype = vim.bo.filetype

     	-- Try to get any treesitter parser for the buffer
   7 	local has_parser, parser = pcall(vim.treesitter.get_parser, 0)
   7 	if not has_parser or not parser then
     		-- Fallback to original filetype if no treesitter parser
   2 		return base_filetype
     	end

   5 	local line, col = get_cursor_position()

     	-- Try to get the language tree at the cursor position
     	-- This will automatically handle language injection (e.g., CSS in HTML, JS in HTML, etc.)
   5 	local lang_tree = parser:language_for_range({ line, col, line, col })
   5 	if lang_tree then
   2 		local lang = lang_tree:lang()
     		-- Return the detected language if it's different from the base filetype
   2 		if lang and lang ~= base_filetype then
   1 			return lang
     		end
     	end

     	-- If language injection doesn't provide a different language, try to get the
     	-- tree at cursor position and check if it's in a different parser context
   4 	local tree_for_range = parser:tree_for_range({ line, col, line, col }, { include_children = true })
   4 	if tree_for_range then
     		-- Get the root language of this tree
   1 		local tree_lang = tree_for_range:lang()
   1 		if tree_lang and tree_lang ~= base_filetype then
   1 			return tree_lang
     		end
     	end

     	-- Check if there are any child parsers (injected languages)
   3 	local children = parser:children()
   4 	for _, child_parser in pairs(children) do
   2 		local child_lang = child_parser:lang()
   2 		if child_lang then
     			-- Check if cursor is within this child parser's range
   2 			local child_trees = child_parser:trees()
   3 			for _, child_tree in ipairs(child_trees) do
   2 				local root = child_tree:root()
   2 				local start_row, start_col, end_row, end_col = root:range()

     				-- Check if cursor is within this child tree's range
   2 				if line >= start_row and line <= end_row then
   1 					if line == start_row and col < start_col then
     						-- Before start
   1 					elseif line == end_row and col > end_col then
     						-- After end
     					else
     						-- Within range
   1 						return child_lang
     					end
     				end
     			end
     		end
     	end

     	-- No injected language found, return base filetype
   2 	return base_filetype
     end

     -- Main function to detect the current language at cursor position
  11 function M.detect_language()
   7 	return detect_language_at_cursor()
     end

     -- Function to get supported embedded languages for a given filetype
     -- This is now more dynamic - it discovers available injected languages
  11 function M.get_supported_languages(filetype)
   3 	local languages = { filetype }

     	-- Try to get parser and check for injected languages
   3 	local has_parser, parser = pcall(vim.treesitter.get_parser, 0)
   3 	if has_parser and parser then
   2 		local children = parser:children()
   4 		for _, child_parser in pairs(children) do
   2 			local child_lang = child_parser:lang()
   2 			if child_lang and child_lang ~= filetype then
     				-- Add to supported languages if not already present
   2 				local found = false
   5 				for _, lang in ipairs(languages) do
   3 					if lang == child_lang then
***0 						found = true
     						break
     					end
     				end
   2 				if not found then
   2 					table.insert(languages, child_lang)
     				end
     			end
     		end
     	end

   3 	return languages
     end

  11 return M

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/logging.lua
==============================================================================
     -- Centralized logging system for Code::Stats plugin
     -- Supports optional file logging with configurable levels

  59 local M = {}

     -- Log levels
  59 M.levels = {
     	ERROR = 1,
     	WARN = 2,
     	INFO = 3,
     	DEBUG = 4,
  59 }

     -- Level names for output
  59 local level_names = {
  59 	[M.levels.ERROR] = "ERROR",
  59 	[M.levels.WARN] = "WARN",
  59 	[M.levels.INFO] = "INFO",
  59 	[M.levels.DEBUG] = "DEBUG",
     }

     -- Default configuration
  59 local config = {
     	enabled = false,
  59 	level = M.levels.INFO,
     	file_path = nil,
     }

     -- Configure logging
  59 function M.setup(user_config)
  33 	if user_config then
  66 		config = vim.tbl_deep_extend("force", config, user_config)
     	end

     	-- Set default log file path if logging is enabled but no path specified
  33 	if config.enabled and not config.file_path then
   1 		local data_dir = vim.fn.stdpath("data")
   1 		config.file_path = data_dir .. "/code-stats.log"
     	end
     end

     -- Get current timestamp for log entries
     local function get_timestamp()
   7 	return os.date("%Y-%m-%d %H:%M:%S")
     end

     -- Write log entry to file
     local function write_to_file(level, message)
 187 	if not config.enabled or not config.file_path then
 178 		return
     	end

   9 	if level > config.level then
   2 		return
     	end

   7 	local timestamp = get_timestamp()
   7 	local level_name = level_names[level] or "UNKNOWN"
   7 	local log_entry = string.format("[%s] [%s] %s\n", timestamp, level_name, message)

     	-- Try to write to log file
   7 	local file = io.open(config.file_path, "a")
   7 	if file then
   6 		file:write(log_entry)
   6 		file:close()
     	end
     end

     -- Log an error message
  59 function M.error(message)
   5 	write_to_file(M.levels.ERROR, message)
     end

     -- Log a warning message
  59 function M.warn(message)
   3 	write_to_file(M.levels.WARN, message)
     end

     -- Log an info message
  59 function M.info(message)
 129 	write_to_file(M.levels.INFO, message)
     end

     -- Log a debug message
  59 function M.debug(message)
  50 	write_to_file(M.levels.DEBUG, message)
     end

     -- Log API requests
  59 function M.log_api_request(url, method, success, error_msg)
   4 	local status = success and "SUCCESS" or "FAILED"
   4 	local msg = string.format("API %s %s - %s", method, url, status)
   4 	if error_msg then
   2 		msg = msg .. " - " .. error_msg
     	end

   4 	if success then
   4 		M.info(msg)
     	else
   2 		M.error(msg)
     	end
     end

     -- Log XP operations
  59 function M.log_xp_operation(operation, language, amount, total)
  35 	local msg = string.format("XP %s: %s +%d (total: %d)", operation, language, amount or 0, total or 0)
  35 	M.info(msg)
     end

     -- Log configuration operations
  59 function M.log_config(message)
  25 	M.info("CONFIG: " .. message)
     end

     -- Log plugin initialization
  59 function M.log_init(message)
  50 	M.info("INIT: " .. message)
     end

     -- Get current log file path
  59 function M.get_log_file()
   2 	return config.file_path
     end

     -- Check if logging is enabled
  59 function M.is_enabled()
   3 	return config.enabled
     end

     -- Clear log file
  59 function M.clear_log()
   1 	if config.enabled and config.file_path then
   1 		local file = io.open(config.file_path, "w")
   1 		if file then
   1 			file:close()
   1 			M.info("Log file cleared")
     		end
     	end
     end

  59 return M

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/notifications.lua
==============================================================================
  10 local logging = require("maorun.code-stats.logging")

  10 local M = {}

     -- Configuration reference (will be set by setup)
  10 local config = nil

     -- Setup notifications with config reference
     M.setup = function(notification_config)
  31 	config = notification_config
  31 	logging.debug("Notifications module configured")
     end

     -- Send level-up notification
     M.level_up = function(language, new_level)
   7 	if not config or not config.notifications.enabled or not config.notifications.level_up.enabled then
   4 		return
     	end

   3 	local message = string.format(config.notifications.level_up.message, language, new_level)

     	-- Use vim.notify if available (Neovim 0.5+), fallback to echo
   4 	if vim.notify then
   2 		vim.notify(message, vim.log.levels.INFO, {
     			title = "Code::Stats",
     			timeout = 3000,
   2 		})
     	else
     		-- Fallback for older Neovim versions
   1 		vim.api.nvim_echo({ { message, "MoreMsg" } }, true, {})
     	end

   3 	logging.info("Level-up notification sent: " .. message)
     end

  10 return M

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/pulse.lua
==============================================================================
  40 local logging = require("maorun.code-stats.logging")
  40 local notifications = require("maorun.code-stats.notifications")
***0 local utils = require("maorun.code-stats.utils")

  40 local pulse = {
     	xps = {},
     }

     -- Get the path for persisting XP data
     local function get_persistence_path()
  21 	local data_dir = vim.fn.stdpath("data")
  40 	return data_dir .. "/code-stats-xp.json"
     end

     -- Save XP data to file (only if there are XP values > 0)
   1 pulse.save = function()
   1 	local has_xp = false
   1 	for _, xp in pairs(pulse.xps) do
   1 		if xp > 0 then
   1 			has_xp = true
     			break
     		end
     	end

***0 	if not has_xp then
     		-- Remove persistence file if no XP to save
***0 		local file_path = get_persistence_path()
***0 		local ok, err = pcall(vim.fn.delete, file_path)
***0 		if not ok then
***0 			logging.warn("Failed to delete empty persistence file: " .. err)
     		else
***0 			logging.debug("Removed empty persistence file")
     		end
***0 		return
     	end

   1 	local file_path = get_persistence_path()
   1 	local ok, data = pcall(vim.fn.json_encode, pulse.xps)
***0 	if not ok then
***0 		logging.error("Failed to encode XP data for persistence: " .. data)
***0 		return
     	end

   1 	local file, err = io.open(file_path, "w")
***0 	if not file then
***0 		logging.error("Failed to open persistence file for writing: " .. (err or "unknown error"))
***0 		return
     	end

   1 	local success, write_err = pcall(file.write, file, data)
***0 	file:close()

***0 	if not success then
***0 		logging.error("Failed to write XP data to persistence file: " .. write_err)
     	else
***0 		logging.info("XP data persisted to file: " .. file_path)
     	end
     end

     -- Load XP data from file and merge with current XP
  11 pulse.load = function()
  11 	local file_path = get_persistence_path()
  11 	local file, err = io.open(file_path, "r")
  10 	if not file then
***0 		if err and not err:match("No such file") then
***0 			logging.warn("Could not open persistence file: " .. err)
     		end
  10 		logging.debug("No persistence file found, starting fresh")
***0 		return -- No persisted data
     	end

   1 	local success, content = pcall(file.read, file, "*all")
***0 	file:close()

***0 	if not success then
***0 		logging.error("Failed to read persistence file: " .. content)
***0 		return
     	end

   1 	if content and content ~= "" then
   1 		local ok, loaded_xps = pcall(vim.fn.json_decode, content)
***0 		if not ok then
***0 			logging.error("Failed to parse persisted XP data: " .. loaded_xps)
     			-- Try to remove corrupted file
***0 			local delete_ok, delete_err = pcall(vim.fn.delete, file_path)
***0 			if not delete_ok then
***0 				logging.warn("Failed to remove corrupted persistence file: " .. delete_err)
     			end
***0 			return
     		end

***0 		if type(loaded_xps) == "table" then
     			-- Merge loaded XP with current XP
   2 			local merged_count = 0
   1 			for lang, xp in pairs(loaded_xps) do
   1 				if type(xp) == "number" and xp > 0 then
   1 					local old_xp = pulse.getXp(lang)
   1 					pulse.xps[lang] = old_xp + xp
   1 					merged_count = merged_count + 1
***0 					logging.debug("Merged " .. xp .. " XP for " .. lang .. " (total: " .. pulse.xps[lang] .. ")")
     				end
     			end
***0 			logging.info("Loaded and merged " .. merged_count .. " languages from persistence file")

     			-- Remove the persistence file after loading
   1 			local delete_ok, delete_err = pcall(vim.fn.delete, file_path)
***0 			if not delete_ok then
***0 				logging.warn("Failed to remove persistence file after loading: " .. delete_err)
     			end
     		else
***0 			logging.error("Invalid persistence file format - expected table, got " .. type(loaded_xps))
     		end
     	end
     end

  36 pulse.addXp = function(lang, amount)
***0 	if not lang or lang == "" then
***0 		logging.warn("Attempted to add XP to empty language")
***0 		return
     	end

   2 	if not amount or amount <= 0 then
   2 		logging.warn("Attempted to add invalid XP amount: " .. tostring(amount))
***0 		return
     	end

  34 	local old_xp = pulse.getXp(lang)
***0 	local old_level = pulse.calculateLevel(old_xp)

  34 	pulse.xps[lang] = old_xp + amount
***0 	local new_level = pulse.calculateLevel(pulse.xps[lang])

***0 	logging.log_xp_operation("ADD", lang, amount, pulse.xps[lang])

     	-- Add to historical tracking for statistics (lazy load to avoid circular dependency)
   7 	local ok, statistics = pcall(require, "maorun.code-stats.statistics")
***0 	if ok then
  74 		statistics.add_history_entry(lang, amount)
     	end

     	-- Check for level-up and send notification
  20 	if new_level > old_level then
***0 		notifications.level_up(lang, new_level)
     	end
     end

     pulse.getXp = function(lang)
***0 	if pulse.xps[lang] then
***0 		return pulse.xps[lang]
     	end
  28 	return 0
     end

     -- Calculate level from XP using shared utility function
     pulse.calculateLevel = function(xp)
***0 	return utils.calculateLevel(xp)
     end

     -- Calculate XP required for a specific level
     pulse.calculateXpForLevel = function(level)
   9 	return utils.calculateXpForLevel(level)
     end

     -- Calculate progress to next level as a percentage (0-100)
     pulse.calculateProgressToNextLevel = function(xp)
   4 	if not xp or xp <= 0 then
   1 		return 0
     	end

   3 	local current_level = pulse.calculateLevel(xp)
   3 	local current_level_xp = pulse.calculateXpForLevel(current_level)
   3 	local next_level_xp = pulse.calculateXpForLevel(current_level + 1)

     	-- If we're at the maximum reasonable level, return 100%
   3 	if current_level >= 100 then
   1 		return 100
     	end

   2 	local xp_in_current_level = xp - current_level_xp
   2 	local xp_needed_for_next = next_level_xp - current_level_xp

   2 	return math.floor((xp_in_current_level / xp_needed_for_next) * 100)
     end

     -- Get level for a specific language
     pulse.getLevel = function(lang)
   2 	local xp = pulse.getXp(lang)
   2 	return pulse.calculateLevel(xp)
     end

     -- Get progress to next level for a specific language
     pulse.getProgressToNextLevel = function(lang)
   1 	local xp = pulse.getXp(lang)
   1 	return pulse.calculateProgressToNextLevel(xp)
     end

     pulse.reset = function()
   9 	local lang_count = 0
  12 	for _ in pairs(pulse.xps) do
   3 		lang_count = lang_count + 1
     	end

   9 	pulse.xps = {}
   9 	logging.info("Reset XP data (" .. lang_count .. " languages cleared)")

     	-- Also remove persistence file when resetting
   9 	local file_path = get_persistence_path()
  10 	local ok, err = pcall(vim.fn.delete, file_path)
   9 	if not ok then
***0 		logging.warn("Failed to delete persistence file during reset: " .. err)
     	end
     end

  40 return pulse

==============================================================================
Summary
==============================================================================

File                                                                                           Hits Missed Coverage
-------------------------------------------------------------------------------------------------------------------
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/api.lua                41   74     35.65%
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/config.lua             33   2      94.29%
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/events.lua             14   7      66.67%
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/init.lua               35   161    17.86%
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/language-detection.lua 48   1      97.96%
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/logging.lua            62   0      100.00%
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/notifications.lua      14   0      100.00%
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/pulse.lua              62   50     55.36%
-------------------------------------------------------------------------------------------------------------------
Total                                                                                          309  295    51.16%
