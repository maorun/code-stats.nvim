==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/api.lua
==============================================================================
  1 local curl = require("plenary.curl")
  1 local pulse = require("maorun.code-stats.pulse")
  1 local cs_config = require("maorun.code-stats.config")

  1 local error_message = ""

    local function requestToApi(body)
**0 	local url = cs_config.config.api_url

**0 	return curl.request({
    		url = url .. "api/my/pulses/",
    		method = "POST",
**0 		headers = {
    			["X-API-Token"] = cs_config.config.api_key,
    			["Content-Type"] = "application/json",
    			["Accept"] = "application/json",
    		},
    		body = body,
    		on_error = function(data)
**0 			error_message = "could not send request to code-stats: " .. data.message
    		end,
    		callback = function()
**0 			error_message = ""
**0 			pulse.reset()
    		end,
    	})
    end

    local function pulseSend()
    	-- Check if config is initialized by checking essential string fields
**0 	local config_values = {
**0 		cs_config.config.status_prefix,
**0 		cs_config.config.api_url,
**0 		cs_config.config.api_key,
    	}
**0 	if string.len(table.concat(config_values)) == 0 then
**0 		error_message = cs_config.config.status_prefix .. "Not Initialized"
    		-- Early return if not initialized, to prevent further checks if config is empty
**0 		if string.len(error_message) > 0 then
**0 			return
    		end
    	end

**0 	local url = cs_config.config.api_url
**0 	if string.len(url) == 0 then
**0 		error_message = "no API-URL given"
**0 		if string.len(error_message) > 0 then
**0 			return
    		end
    	end
**0 	if string.len(cs_config.config.api_key) == 0 then
**0 		error_message = "no api-key given"
**0 		if string.len(error_message) > 0 then
**0 			return
    		end
    	end

    	-- If there was an error message set by previous checks, clear it if we proceed
**0 	error_message = ""

**0 	local languages = vim.fn.map(pulse.xps, function(language, xp)
**0 		if xp > 0 then
**0 			return '{"language": "' .. language .. '", "xp": ' .. xp .. "}"
    		else
**0 			return ""
    		end
    	end)

**0 	local xps = table.concat(vim.tbl_values(languages), ",")

**0 	if string.len(xps) > 0 then
**0 		requestToApi('{ "coded_at": "' .. os.date("%Y-%m-%dT%X%z") .. '", "xps": [ ' .. xps .. " ] }")
    	end
    end

    local function get_error()
**0 	return error_message
    end

  1 return {
  1 	pulseSend = pulseSend,
  1 	requestToApi = requestToApi,
  1 	get_error = get_error,
  1 }

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/config.lua
==============================================================================
  5 local defaults = {
    	status_prefix = "C:S ",
    	api_url = "https://codestats.net/",
    	api_key = "",
  5 	ignored_filetypes = {},
    }
  5 local config = defaults

  5 local M = {
 10 	config = vim.deepcopy(defaults),
    }

  5 function M.setup(user_config)
  7 	local globalConfig = {}
  7 	if vim.g.codestats_api_key then
**0 		globalConfig.api_key = vim.g.codestats_api_key
    	end
 14 	config = vim.tbl_deep_extend("force", defaults, user_config or {}, globalConfig)
  7 	M.config = config
  7 	return config
    end

  5 return M

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/events.lua
==============================================================================
  1 local lang_detection = require("maorun.code-stats.language-detection")

    local function setup_autocommands(add_xp_callback, pulse_send_callback)
  1 	local group = vim.api.nvim_create_augroup("codestats_track", { clear = true })

  2 	vim.api.nvim_create_autocmd({ "InsertCharPre", "TextChanged" }, {
  1 		group = group,
    		pattern = "*",
    		callback = function()
**0 			if add_xp_callback then
**0 				local detected_lang = lang_detection.detect_language()
**0 				add_xp_callback(detected_lang)
    			end
    		end,
    	})

  2 	vim.api.nvim_create_autocmd("VimLeavePre", {
  1 		group = group,
    		pattern = "*",
    		callback = function()
**0 			if pulse_send_callback then
**0 				pulse_send_callback()
    			end
    		end,
    	})

  2 	vim.api.nvim_create_autocmd({ "BufWrite", "BufLeave" }, {
  1 		group = group,
    		pattern = "*",
    		callback = function()
**0 			if pulse_send_callback then
**0 				pulse_send_callback()
    			end
    		end,
    	})
    end

  1 return {
  1 	setup_autocommands = setup_autocommands,
  1 }

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/init.lua
==============================================================================
  1 local pulse = require("maorun.code-stats.pulse")
  1 local cs_config = require("maorun.code-stats.config")
  1 local api = require("maorun.code-stats.api")
  1 local events = require("maorun.code-stats.events")
  1 local lang_detection = require("maorun.code-stats.language-detection")

    -- The local 'error' variable has been removed. Errors are now primarily managed in api.lua.

    local function currentXp()
    	-- currentXp now relies on M.getError() which gets its value from api.get_error()
**0 	if string.len(api.get_error()) > 0 then
**0 		return cs_config.config.status_prefix .. "ERR"
    	end

**0 	local detected_lang = lang_detection.detect_language()
**0 	return cs_config.config.status_prefix .. pulse.getXp(detected_lang)
    end

  1 local M = {}

  1 function M.add(filetype)
    	-- Check if filetype is in ignored list
 10 	for _, ignored_type in ipairs(cs_config.config.ignored_filetypes) do
  8 		if filetype == ignored_type then
  3 			return -- Don't add XP for ignored filetypes
    		end
    	end
  2 	pulse.addXp(filetype, 1)
    end

  1 M.setup = cs_config.setup
  1 M.pulseSend = api.pulseSend
  1 M.currentXp = currentXp
    M.getError = function()
**0 	return api.get_error()
    end

    -- Setup autocommands by passing the local add function and api.pulseSend
  1 events.setup_autocommands(M.add, M.pulseSend)

  1 return M

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/language-detection.lua
==============================================================================
 10 local M = {}

    -- Get the current cursor position
    local function get_cursor_position()
  5 	local cursor = vim.api.nvim_win_get_cursor(0)
  5 	return cursor[1] - 1, cursor[2] -- Convert to 0-indexed for treesitter
    end

    -- Attempt to detect language using treesitter language injection
    local function detect_language_at_cursor()
  6 	local base_filetype = vim.bo.filetype

    	-- Try to get any treesitter parser for the buffer
  6 	local has_parser, parser = pcall(vim.treesitter.get_parser, 0)
  6 	if not has_parser or not parser then
    		-- Fallback to original filetype if no treesitter parser
  1 		return base_filetype
    	end

  5 	local line, col = get_cursor_position()

    	-- Try to get the language tree at the cursor position
    	-- This will automatically handle language injection (e.g., CSS in HTML, JS in HTML, etc.)
  5 	local lang_tree = parser:language_for_range({ line, col, line, col })
  5 	if lang_tree then
  2 		local lang = lang_tree:lang()
    		-- Return the detected language if it's different from the base filetype
  2 		if lang and lang ~= base_filetype then
  1 			return lang
    		end
    	end

    	-- If language injection doesn't provide a different language, try to get the
    	-- tree at cursor position and check if it's in a different parser context
  4 	local tree_for_range = parser:tree_for_range({ line, col, line, col }, { include_children = true })
  4 	if tree_for_range then
    		-- Get the root language of this tree
  1 		local tree_lang = tree_for_range:lang()
  1 		if tree_lang and tree_lang ~= base_filetype then
  1 			return tree_lang
    		end
    	end

    	-- Check if there are any child parsers (injected languages)
  3 	local children = parser:children()
  4 	for _, child_parser in pairs(children) do
  2 		local child_lang = child_parser:lang()
  2 		if child_lang then
    			-- Check if cursor is within this child parser's range
  2 			local child_trees = child_parser:trees()
  3 			for _, child_tree in ipairs(child_trees) do
  2 				local root = child_tree:root()
  2 				local start_row, start_col, end_row, end_col = root:range()

    				-- Check if cursor is within this child tree's range
  2 				if line >= start_row and line <= end_row then
  1 					if line == start_row and col < start_col then
    						-- Before start
  1 					elseif line == end_row and col > end_col then
    						-- After end
    					else
    						-- Within range
  1 						return child_lang
    					end
    				end
    			end
    		end
    	end

    	-- No injected language found, return base filetype
  2 	return base_filetype
    end

    -- Main function to detect the current language at cursor position
 10 function M.detect_language()
  6 	return detect_language_at_cursor()
    end

    -- Function to get supported embedded languages for a given filetype
    -- This is now more dynamic - it discovers available injected languages
 10 function M.get_supported_languages(filetype)
  3 	local languages = { filetype }

    	-- Try to get parser and check for injected languages
  3 	local has_parser, parser = pcall(vim.treesitter.get_parser, 0)
  3 	if has_parser and parser then
  2 		local children = parser:children()
  4 		for _, child_parser in pairs(children) do
  2 			local child_lang = child_parser:lang()
  2 			if child_lang and child_lang ~= filetype then
    				-- Add to supported languages if not already present
  2 				local found = false
  5 				for _, lang in ipairs(languages) do
  3 					if lang == child_lang then
**0 						found = true
    						break
    					end
    				end
  2 				if not found then
  2 					table.insert(languages, child_lang)
    				end
    			end
    		end
    	end

  3 	return languages
    end

 10 return M

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/pulse.lua
==============================================================================
  8 local pulse = {
  8 	xps = {},
    }

    pulse.addXp = function(lang, amount)
 24 	pulse.xps[lang] = pulse.getXp(lang) + amount
    end

    pulse.getXp = function(lang)
 27 	if pulse.xps[lang] then
 11 		return pulse.xps[lang]
    	end
 16 	return 0
    end

    pulse.reset = function()
  3 	pulse.xps = {}
    end

  8 return pulse

==============================================================================
Summary
==============================================================================

File                                                                                           Hits Missed Coverage
-------------------------------------------------------------------------------------------------------------------
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/api.lua                9    32     21.95%
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/config.lua             12   1      92.31%
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/events.lua             11   7      61.11%
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/init.lua               16   5      76.19%
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/language-detection.lua 48   1      97.96%
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/pulse.lua              8    0      100.00%
-------------------------------------------------------------------------------------------------------------------
Total                                                                                          104  46     69.33%
