==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/block.lua
==============================================================================
***0 local getfenv = require 'busted.compatibility'.getfenv
***0 local unpack = require 'busted.compatibility'.unpack
***0 local shuffle = require 'busted.utils'.shuffle

     local function sort(elements)
***0   table.sort(elements, function(t1, t2)
***0     if t1.name and t2.name then
***0       return t1.name < t2.name
         end
***0     return t2.name ~= nil
       end)
***0   return elements
     end

     return function(busted)
   1   local block = {}
   1   local root = busted.context.get()

   1   function block.reject(descriptor, element)
***0     element.env[descriptor] = function(...)
***0       error("'" .. descriptor .. "' not supported inside current context block", 2)
         end
       end

   1   function block.rejectAll(element)
***0     local env = getfenv(element.run)
***0     block.reject('randomize', element)
***0     for descriptor, _ in pairs(busted.executors) do
***0       if root.env[descriptor] and (env ~= _G and env[descriptor] or rawget(env, descriptor)) then
***0         block.reject(descriptor, element)
           end
         end
       end

       local function exec(descriptor, element)
***0     if not element.env then element.env = {} end
***0     block.rejectAll(element)
***0     local ret = { busted.safe(descriptor, element.run, element) }
***0     return unpack(ret)
       end

   1   function block.execAllOnce(descriptor, current, err)
***0     local parent = busted.context.parent(current)

***0     if parent then
***0       local success = block.execAllOnce(descriptor, parent)
***0       if not success then
***0         return success
           end
         end

***0     if not current[descriptor] then
***0       current[descriptor] = {}
         end
***0     local list = current[descriptor]
***0     if list.success ~= nil then
***0       return list.success
         end

***0     local success = true
***0     for _, v in ipairs(list) do
***0       if not exec(descriptor, v):success() then
***0         if err then err(descriptor) end
***0         success = false
           end
         end

***0     list.success = success

***0     return success
       end

   1   function block.execAll(descriptor, current, propagate, err)
   2     local parent = busted.context.parent(current)

   2     if propagate and parent then
***0       local success, ancestor = block.execAll(descriptor, parent, propagate)
***0       if not success then
***0         return success, ancestor
           end
         end

   2     local list = current[descriptor] or {}

   2     local success = true
   2     for _, v in ipairs(list) do
***0       if not exec(descriptor, v):success() then
***0         if err then err(descriptor) end
***0         success = nil
           end
         end
   2     return success, current
       end

   1   function block.dexecAll(descriptor, current, propagate, err)
   2     local parent = busted.context.parent(current)
   2     local list = current[descriptor] or {}

   2     local success = true
   2     for _, v in ipairs(list) do
***0       if not exec(descriptor, v):success() then
***0         if err then err(descriptor) end
***0         success = nil
           end
         end

   2     if propagate and parent then
***0       if not block.dexecAll(descriptor, parent, propagate) then
***0         success = nil
           end
         end
   2     return success
       end

   1   function block.lazySetup(element, err)
***0     return block.execAllOnce('lazy_setup', element, err)
       end

   1   function block.lazyTeardown(element, err)
   2     if element.lazy_setup and element.lazy_setup.success ~= nil then
***0       block.dexecAll('lazy_teardown', element, nil, err)
***0       element.lazy_setup.success = nil
         end
       end

   1   function block.setup(element, err)
   2       return block.execAll('strict_setup', element, nil, err)
       end

   1   function block.teardown(element, err)
   2       return block.dexecAll('strict_teardown', element, nil, err)
       end

   1   function block.execute(descriptor, element)
   1     if not element.env then element.env = {} end

   1     local randomize = busted.randomize
   1     local randomseed = busted.randomseed
   1     element.env.randomize = function(...)
***0       randomize = (select('#', ...) == 0 or ...)
***0       if randomize then
***0         randomseed = tonumber(({...})[1]) or tonumber(({...})[2]) or randomseed
           end
         end

   3     if busted.safe(descriptor, element.run, element):success() then
   1       if busted.sort then
***0         sort(busted.context.children(element))
   1       elseif randomize then
***0         element.randomseed = randomseed
***0         shuffle(busted.context.children(element), randomseed)
           end

   2       if block.setup(element) then
   1         busted.execute(element)
           end

   1       block.lazyTeardown(element)
   1       block.teardown(element)
         end
       end

   1   return block
     end

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/context.lua
==============================================================================
***0 local tablex = require 'pl.tablex'

     local function save()
   1   local g = {}
  47   for k,_ in next, _G, nil do
  46     g[k] = rawget(_G, k)
       end
   1   return {
   1     gmt = debug.getmetatable(_G),
   1     g = g,
   2     loaded = tablex.copy(package.loaded)
   1   }
     end

     local function restore(state)
   1   setmetatable(_G, state.gmt)
  47   for k,_ in next, _G, nil do
  46     rawset(_G, k, state.g[k])
       end
  47   for k, v in next, state.g, nil do
         -- reset globals that were set to nil during the insulation block
  46     if rawget(_G, k) == nil then
***0       rawset(_G, k, v)
         end
       end
 112   for k,_ in pairs(package.loaded) do
 111     package.loaded[k] = state.loaded[k]
       end
     end

     return function()
***0   local context = {}

***0   local data = { descriptor = 'suite', attributes = {} }
***0   local parents = {}
***0   local children = {}
***0   local stack = {}
***0   local states = {}

***0   function context.ref()
***0     local ref = {}
***0     local ctx = data

         local function unwrap(element, levels)
***0       local levels = levels or 1
***0       local parent = element
***0       for i = 1, levels do
***0         parent = ref.parent(parent)
***0         if not parent then break end
           end
***0       if not element.env then element.env = {} end
***0       setmetatable(element.env, {
             __newindex = function(self, key, value)
***0           if not parent then
***0             _G[key] = value
               else
***0             if not parent.env then parent.env = {} end
***0             parent.env[key] = value
               end
             end
           })
         end

         local function push_state(current)
   1       local state = false
   1       if current.attributes.envmode == 'insulate' then
   2         state = save()
***0       elseif current.attributes.envmode == 'unwrap' then
***0         unwrap(current)
***0       elseif current.attributes.envmode == 'expose' then
***0         unwrap(current, 2)
           end
   1       table.insert(states, state)
         end

         local function pop_state(current)
   1       local state = table.remove(states)
   1       if current.attributes.envmode == 'expose' then
***0         states[#states] = states[#states] and save()
           end
   1       if state then
   1         restore(state)
           end
         end

***0     function ref.get(key)
   6       if not key then return ctx end
***0       return ctx[key]
         end

***0     function ref.set(key, value)
***0       ctx[key] = value
         end

***0     function ref.clear()
***0       data = { descriptor = 'suite', attributes = {} }
***0       parents = {}
***0       children = {}
***0       stack = {}
***0       states = {}
***0       ctx = data
         end

***0     function ref.attach(child)
   1       if not children[ctx] then children[ctx] = {} end
   1       parents[child] = ctx
   1       table.insert(children[ctx], child)
         end

***0     function ref.children(parent)
   3       return children[parent] or {}
         end

***0     function ref.parent(child)
   6       return parents[child]
         end

***0     function ref.push(current)
   6       if not parents[current] and current ~= data then error('Detached child. Cannot push.') end
   6       if ctx ~= current then push_state(current) end
   6       table.insert(stack, ctx)
   6       ctx = current
         end

***0     function ref.pop()
   6       local current = ctx
  12       ctx = table.remove(stack)
   6       if ctx ~= current then pop_state(current) end
   6       if not ctx then error('Context stack empty. Cannot pop.') end
         end

***0     return ref
       end

***0   return context
     end

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/core.lua
==============================================================================
***0 local getfenv = require 'busted.compatibility'.getfenv
***0 local setfenv = require 'busted.compatibility'.setfenv
***0 local unpack = require 'busted.compatibility'.unpack
***0 local path = require 'pl.path'
***0 local pretty = require 'pl.pretty'
***0 local system = require 'system'
***0 local throw = error

***0 local failureMt = {
       __index = {},
       __tostring = function(e) return tostring(e.message) end,
***0   __type = 'failure'
     }

***0 local failureMtNoString = {
       __index = {},
***0   __type = 'failure'
     }

***0 local pendingMt = {
       __index = {},
       __tostring = function(p) return p.message end,
***0   __type = 'pending'
     }

     local function errortype(obj)
***0   local mt = debug.getmetatable(obj)
***0   if mt == failureMt or mt == failureMtNoString then
***0     return 'failure'
***0   elseif mt == pendingMt then
***0     return 'pending'
       end
***0   return 'error'
     end

     local function hasToString(obj)
***0   return type(obj) == 'string' or (debug.getmetatable(obj) or {}).__tostring
     end

     local function isCallable(obj)
   1   return type(obj) == 'function' or (debug.getmetatable(obj) or {}).__call
     end

     return function()
***0   local mediator = require 'mediator'()

***0   local busted = {}
***0   busted.version = '2.2.0'

***0   local root = require 'busted.context'()
***0   busted.context = root.ref()

***0   local environment = require 'busted.environment'(busted.context)

***0   busted.api = {}
***0   busted.executors = {}
***0   local executors = {}
***0   local eattributes = {}

***0   busted.gettime = system.gettime
***0   busted.monotime = system.monotime
***0   busted.sleep = system.sleep
***0   busted.status = require 'busted.status'

***0   function busted.getTrace(element, level, msg)
         local function trimTrace(info)
***0       local index = info.traceback:find('\n%s*%[C]')
***0       info.traceback = info.traceback:sub(1, index)
***0       return info
         end
***0     level = level or  3

***0     local thisdir = path.dirname(debug.getinfo(1, 'Sl').source)
***0     local info = debug.getinfo(level, 'Sl')
***0     while info.what == 'C' or info.short_src:match('luassert[/\\].*%.lua$') or
***0           (info.source:sub(1,1) == '@' and thisdir == path.dirname(info.source)) do
***0       level = level + 1
***0       info = debug.getinfo(level, 'Sl')
         end

***0     info.traceback = debug.traceback('', level)
***0     info.message = tostring(msg)

***0     local file = busted.getFile(element)
***0     return file and file.getTrace(file.name, info) or trimTrace(info)
       end

***0   function busted.rewriteMessage(element, message, trace)
***0     local file = busted.getFile(element)
***0     local msg = hasToString(message) and tostring(message)
***0     msg = msg or (message ~= nil and pretty.write(message) or 'Nil error')
***0     msg = (file and file.rewriteMessage and file.rewriteMessage(file.name, msg) or msg)

***0     local hasFileLine = msg:match('^[^\n]-:%d+: .*')
***0     if not hasFileLine then
***0       local trace = trace or busted.getTrace(element, 3, message)
***0       local fileline = trace.short_src .. ':' .. trace.currentline .. ': '
***0       msg = fileline .. msg
         end

***0     return msg
       end

***0   function busted.publish(...)
   6     return mediator:publish(...)
       end

***0   function busted.subscribe(...)
  34     return mediator:subscribe(...)
       end

***0   function busted.unsubscribe(...)
***0     return mediator:removeSubscriber(...)
       end

***0   function busted.getFile(element)
***0     local parent = busted.context.parent(element)

***0     while parent do
***0       if parent.file then
***0         local file = parent.file[1]
***0         return {
               name = file.name,
               getTrace = file.run.getTrace,
***0           rewriteMessage = file.run.rewriteMessage
             }
           end

***0       if parent.descriptor == 'file' then
***0         return {
               name = parent.name,
               getTrace = parent.run.getTrace,
***0           rewriteMessage = parent.run.rewriteMessage
             }
           end

***0       parent = busted.context.parent(parent)
         end

***0     return parent
       end

***0   function busted.fail(msg, level)
***0     local rawlevel = (type(level) ~= 'number' or level <= 0) and level
***0     local level = level or 1
***0     local _, emsg = pcall(throw, msg, rawlevel or level+2)
***0     local e = { message = emsg }
***0     setmetatable(e, hasToString(msg) and failureMt or failureMtNoString)
***0     throw(e, rawlevel or level+1)
       end

***0   function busted.pending(msg)
***0     local p = { message = msg }
***0     setmetatable(p, pendingMt)
***0     throw(p)
       end

***0   function busted.bindfenv(callable, var, value)
***0     local env = {}
***0     local f = (debug.getmetatable(callable) or {}).__call or callable
***0     setmetatable(env, { __index = getfenv(f) })
***0     env[var] = value
***0     setfenv(f, env)
       end

***0   function busted.wrap(callable)
   2     if isCallable(callable) then
           -- prioritize __call if it exists, like in files
   1       environment.wrap((debug.getmetatable(callable) or {}).__call or callable)
         end
       end

***0   function busted.safe(descriptor, run, element)
   6     busted.context.push(element)
         local trace, message
   6     local status = 'success'

  12     local ret = { xpcall(run, function(msg)
***0       status = errortype(msg)
***0       trace = busted.getTrace(element, 3, msg)
***0       message = busted.rewriteMessage(element, msg, trace)
  12     end) }

   6     if not ret[1] then
***0       if status == 'success' then
***0         status = 'error'
***0         trace = busted.getTrace(element, 3, ret[2])
***0         message = busted.rewriteMessage(element, ret[2], trace)
***0       elseif status == 'failure' and descriptor ~= 'it' then
             -- Only 'it' blocks can generate test failures. Failures in all
             -- other blocks are errors outside the test.
***0         status = 'error'
           end
           -- Note: descriptor may be different from element.descriptor when
           -- safe_publish is used (i.e. for test start/end). The safe_publish
           -- descriptor needs to be different for 'it' blocks so that we can
           -- detect that a 'failure' in a test start/end handler is not really
           -- a test failure, but rather an error outside the test, much like a
           -- failure in a support function (i.e. before_each/after_each or
           -- setup/teardown).
***0       busted.publish({ status, element.descriptor }, element, busted.context.parent(element), message, trace)
         end
  12     ret[1] = busted.status(status)

   6     busted.context.pop()
   6     return unpack(ret)
       end

***0   function busted.safe_publish(descriptor, channel, element, ...)
   4     local args = {...}
   4     local n = select('#', ...)
   4     if channel[2] == 'start' then
   2       element.starttick = busted.monotime()
   2       element.starttime = busted.gettime()
   2     elseif channel[2] == 'end' then
   2       element.endtime = busted.gettime()
   2       element.endtick = busted.monotime()
   2       element.duration = element.starttick and (element.endtick - element.starttick)
         end
   8     local status = busted.safe(descriptor, function()
   4       busted.publish(channel, element, unpack(args, 1, n))
   8     end, element)
   4     return status:success()
       end

***0   function busted.exportApi(key, value)
***0     busted.api[key] = value
       end

***0   function busted.export(key, value)
***0     busted.exportApi(key, value)
***0     environment.set(key, value)
       end

***0   function busted.hide(key, value)
***0     busted.api[key] = nil
***0     environment.set(key, nil)
       end

***0   function busted.register(descriptor, executor, attributes)
         local alias = nil
***0     if type(executor) == 'string' then
***0       alias = descriptor
***0       descriptor = executor
***0       executor = executors[descriptor]
***0       attributes = attributes or eattributes[descriptor]
***0       executors[alias] = executor
***0       eattributes[alias] = attributes
         else
***0       if executor ~= nil and not isCallable(executor) then
***0         attributes = executor
***0         executor = nil
           end
***0       executors[descriptor] = executor
***0       eattributes[descriptor] = attributes
         end

         local publisher = function(name, fn)
   1       if not fn and type(name) == 'function' then
***0         fn = name
***0         name = alias
   1       elseif not fn then
***0         fn = attributes and attributes.default_fn
           end

           local trace

   1       local ctx = busted.context.get()
   2       if busted.context.parent(ctx) then
***0         trace = busted.getTrace(ctx, 3, name)
           end

           local publish = function(f)
   1         busted.publish({ 'register', descriptor }, name, f, trace, attributes)
           end

   2       if fn then publish(fn) else return publish end
         end

***0     local edescriptor = alias or descriptor
***0     busted.executors[edescriptor] = publisher
***0     busted.export(edescriptor, publisher)

***0     busted.subscribe({ 'register', descriptor }, function(name, fn, trace, attributes)
   1       local ctx = busted.context.get()
   1       local plugin = {
   1         descriptor = descriptor,
   1         attributes = attributes or {},
   1         name = name,
   1         run = fn,
   1         trace = trace,
             starttick = nil,
             endtick = nil,
             starttime = nil,
             endtime = nil,
             duration = nil,
           }

   1       busted.context.attach(plugin)

   1       if not ctx[descriptor] then
   1         ctx[descriptor] = { plugin }
           else
***0         ctx[descriptor][#ctx[descriptor]+1] = plugin
           end
         end)
       end

***0   function busted.execute(current)
   3     if not current then current = busted.context.get() end
   5     for _, v in pairs(busted.context.children(current)) do
   1       local executor = executors[v.descriptor]
   1       if executor and not busted.skipAll then
   3         busted.safe(v.descriptor, function() executor(v) end, v)
           end
         end
       end

***0   return busted
     end

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/environment.lua
==============================================================================
***0 local setfenv = require 'busted.compatibility'.setfenv

     return function(context)

***0   local environment = {}

       local function getEnv(self, key)
   2     if not self then return nil end
***0     return
   2       self.env and self.env[key] or
   3       getEnv(context.parent(self), key) or
   2       _G[key]
       end

       local function setEnv(self, key, value)
***0     if not self.env then self.env = {} end
***0     self.env[key] = value
       end

       local function __index(self, key)
   2     return getEnv(context.get(), key)
       end

       local function __newindex(self, key, value)
***0     setEnv(context.get(), key, value)
       end

***0   local env = setmetatable({}, { __index=__index, __newindex=__newindex })

***0   function environment.wrap(fn)
   1     return setfenv(fn, env)
       end

***0   function environment.set(key, value)
***0     local env = context.get('env')

***0     if not env then
***0       env = {}
***0       context.set('env', env)
         end

***0     env[key] = value
       end
***0   return environment
     end

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/execute.lua
==============================================================================
   1 local shuffle = require 'busted.utils'.shuffle
   1 local urandom = require 'busted.utils'.urandom
   1 local tablex = require 'pl.tablex'

     local function sort(elements)
***0   table.sort(elements, function(t1, t2)
***0     if t1.name and t2.name then
***0       return t1.name < t2.name
         end
***0     return t2.name ~= nil
       end)
***0   return elements
     end

     return function(busted)
   1   local block = require 'busted.block'(busted)

       local function execute(runs, options)
   1     local root = busted.context.get()
   2     local children = tablex.copy(busted.context.children(root))

         local function suite_reset()
***0       local oldctx = busted.context.get()

***0       busted.context.clear()
***0       local ctx = busted.context.get()
***0       for k, v in pairs(oldctx) do
***0         ctx[k] = v
           end

***0       for _, child in ipairs(children) do
***0         for descriptor, _ in pairs(busted.executors) do
***0           child[descriptor] = nil
             end
***0         busted.context.attach(child)
           end

***0       busted.randomseed = tonumber(options.seed) or urandom() or os.time()
         end

   2     for i = 1, runs do
   1       if i > 1 then
***0         suite_reset()
***0         root = busted.context.get()
***0         busted.safe_publish('suite', { 'suite', 'reset' }, root, i, runs)
           end

   1       if options.sort then
***0         sort(busted.context.children(root))
   1       elseif options.shuffle then
***0         root.randomseed = busted.randomseed
***0         shuffle(busted.context.children(root), busted.randomseed)
           end

   1       local seed = (busted.randomize and busted.randomseed or nil)
   2       if busted.safe_publish('suite', { 'suite', 'start' }, root, i, runs, seed) then
   2         if block.setup(root) then
   1           busted.execute()
             end
   1         block.lazyTeardown(root)
   1         block.teardown(root)
           end
   1       busted.safe_publish('suite', { 'suite', 'end' }, root, i, runs)

   1       if busted.skipAll then
             break
           end
         end
       end

   1   return execute
     end

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/init.lua
==============================================================================
     local function init(busted)
***0   local block = require 'busted.block'(busted)

       local file = function(file)
   1     busted.wrap(file.run)
   2     if busted.safe_publish('file', { 'file', 'start' }, file) then
   1       block.execute('file', file)
         end
   1     busted.safe_publish('file', { 'file', 'end' }, file)
       end

       local describe = function(describe)
***0     local parent = busted.context.parent(describe)
***0     if busted.safe_publish('describe', { 'describe', 'start' }, describe, parent) then
***0       block.execute('describe', describe)
         end
***0     busted.safe_publish('describe', { 'describe', 'end' }, describe, parent)
       end

       local it = function(element)
***0     local parent = busted.context.parent(element)
         local finally

***0     if not block.lazySetup(parent) then
           -- skip test if any setup failed
***0       return
         end

***0     if not element.env then element.env = {} end

***0     block.rejectAll(element)
***0     element.env.finally = function(fn) finally = fn end
***0     element.env.pending = busted.pending

***0     local pass, ancestor = block.execAll('before_each', parent, true)

***0     if pass then
***0       local status = busted.status('success')
***0       if busted.safe_publish('test', { 'test', 'start' }, element, parent) then
***0         status:update(busted.safe('it', element.run, element))
***0         if finally then
***0           block.reject('pending', element)
***0           status:update(busted.safe('finally', finally, element))
             end
           else
***0         status = busted.status('error')
           end
***0       busted.safe_publish('test', { 'test', 'end' }, element, parent, tostring(status))
         end

***0     block.dexecAll('after_each', ancestor, true)
       end

       local pending = function(element)
***0     local parent = busted.context.parent(element)
***0     local status = 'pending'
***0     if not busted.safe_publish('it', { 'test', 'start' }, element, parent) then
***0       status = 'error'
         end
***0     busted.safe_publish('it', { 'test', 'end' }, element, parent, status)
       end

***0   busted.register('file', file, { envmode = 'insulate' })

***0   busted.register('describe', describe)
***0   busted.register('insulate', 'describe', { envmode = 'insulate' })
***0   busted.register('expose', 'describe', { envmode = 'expose' })

***0   busted.register('it', it)

***0   busted.register('pending', pending, { default_fn = function() end })

***0   busted.register('before_each', { envmode = 'unwrap' })
***0   busted.register('after_each', { envmode = 'unwrap' })

***0   busted.register('lazy_setup', { envmode = 'unwrap' })
***0   busted.register('lazy_teardown', { envmode = 'unwrap' })
***0   busted.register('strict_setup', { envmode = 'unwrap' })
***0   busted.register('strict_teardown', { envmode = 'unwrap' })

***0   busted.register('setup', 'strict_setup')
***0   busted.register('teardown', 'strict_teardown')

***0   busted.register('context', 'describe')
***0   busted.register('spec', 'it')
***0   busted.register('test', 'it')

***0   busted.hide('file')

***0   local assert = require 'luassert'
***0   local spy    = require 'luassert.spy'
***0   local mock   = require 'luassert.mock'
***0   local stub   = require 'luassert.stub'
***0   local match  = require 'luassert.match'

       require 'busted.fixtures'  -- just load into the environment, not exposing it

***0   busted.export('assert', assert)
***0   busted.export('spy', spy)
***0   busted.export('mock', mock)
***0   busted.export('stub', stub)
***0   busted.export('match', match)

***0   busted.exportApi('publish', busted.publish)
***0   busted.exportApi('subscribe', busted.subscribe)
***0   busted.exportApi('unsubscribe', busted.unsubscribe)

***0   busted.exportApi('bindfenv', busted.bindfenv)
***0   busted.exportApi('fail', busted.fail)
***0   busted.exportApi('gettime', busted.gettime)
***0   busted.exportApi('monotime', busted.monotime)
***0   busted.exportApi('sleep', busted.sleep)
***0   busted.exportApi('parent', busted.context.parent)
***0   busted.exportApi('children', busted.context.children)
***0   busted.exportApi('version', busted.version)

***0   busted.bindfenv(assert, 'error', busted.fail)
***0   busted.bindfenv(assert.is_true, 'error', busted.fail)

***0   return busted
     end

***0 return setmetatable({}, {
       __call = function(self, busted)
***0     init(busted)

***0     return setmetatable(self, {
           __index = function(self, key)
  17         return busted.api[key]
           end,

           __newindex = function(self, key, value)
***0         error('Attempt to modify busted')
           end
         })
       end
     })

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/languages/en.lua
==============================================================================
   1 local s = require('say')

   1 s:set_namespace('en')

     -- 'Pending: test.lua @ 12 \n description
   1 s:set('output.pending', 'Pending')
   1 s:set('output.failure', 'Failure')
   1 s:set('output.error', 'Error')
   1 s:set('output.success', 'Success')

   1 s:set('output.pending_plural', 'pending')
   1 s:set('output.failure_plural', 'failures')
   1 s:set('output.error_plural', 'errors')
   1 s:set('output.success_plural', 'successes')

   1 s:set('output.pending_zero', 'pending')
   1 s:set('output.failure_zero', 'failures')
   1 s:set('output.error_zero', 'errors')
   1 s:set('output.success_zero', 'successes')

   1 s:set('output.pending_single', 'pending')
   1 s:set('output.failure_single', 'failure')
   1 s:set('output.error_single', 'error')
   1 s:set('output.success_single', 'success')

   1 s:set('output.seconds', 'seconds')

   1 s:set('output.no_test_files_match', 'No test files found matching Lua pattern: %s')
   1 s:set('output.file_not_found', 'Cannot find file or directory: %s')

     -- definitions following are not used within the 'say' namespace
   1 return {
   1   failure_messages = {
         'You have %d busted specs',
         'Your specs are busted',
         'Your code is bad and you should feel bad',
         'Your code is in the Danger Zone',
         'Strange game. The only way to win is not to test',
         'My grandmother wrote better specs on a 3 86',
         'Every time there\'s a failure, drink another beer',
         'Feels bad man'
   1   },
   1   success_messages = {
         'Aww yeah, passing specs',
         'Doesn\'t matter, had specs',
         'Feels good, man',
         'Great success',
         'Tests pass, drink another beer',
   1   }
   1 }

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/luajit.lua
==============================================================================
   1 local isJit = (tostring(assert):match('builtin') ~= nil)

   1 if not isJit then
***0   return function() end
     end

     -- pre-load the ffi module, such that it becomes part of the environment
     -- and Busted will not try to GC and reload it. The ffi is not suited
     -- for that and will occasionally segfault if done so.
   1 local ffi = require "ffi"


     -- patching assumes;
     --  * first parameter to be a unique key to identify repeated calls
     --  * only a single return value

     local function patch_with_return_value(func_name)
   3   local original = ffi[func_name]
   3   local original_store = {}

   3   ffi[func_name] = function (primary, ...)
***0     if original_store[primary] then
***0       return original_store[primary]
         end
***0     local success, result, err = pcall(original, primary, ...)
***0     if not success then
           -- hard error was thrown
***0       error(result, 2)
         end
***0     if not result then
           -- soft error was returned
***0       return result, err
         end
         -- it worked, store and return
***0     original_store[primary] = result
***0     return result
       end
     end

     local function patch_without_return_value(func_name)
   1   local original = ffi[func_name]
   1   local original_store = {}

   1   ffi[func_name] = function (primary, ...)
***0     if original_store[primary] then
***0       return
         end
***0     local success, result = pcall(original, primary, ...)
***0     if not success then
           -- hard error was thrown
***0       error(result, 2)
         end
         -- store and return
***0     original_store[primary] = true
***0     return result
       end
     end

     return function()
   1     patch_without_return_value("cdef")
   1     patch_with_return_value("typeof")
   1     patch_with_return_value("metatype")
   1     patch_with_return_value("load")
       end

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/modules/files/lua.lua
==============================================================================
   1 local path = require 'pl.path'

   1 local ret = {}

     local getTrace = function(filename, info)
***0   local index = info.traceback:find('\n%s*%[C]')
***0   info.traceback = info.traceback:sub(1, index)
***0   return info
     end

     ret.match = function(busted, filename)
   2   return path.extension(filename) == '.lua'
     end

     ret.load = function(busted, filename)
   1   local file, err = loadfile(filename)
   1   if not file then
***0     busted.publish({ 'error', 'file' }, { descriptor = 'file', name = filename }, nil, err, {})
       end
   1   return file, getTrace
     end

   1 return ret

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/modules/files/moonscript.lua
==============================================================================
   1 local path = require 'pl.path'

   2 local ok, moonscript, line_tables, util = pcall(function()
   1   return require 'moonscript', require 'moonscript.line_tables', require 'moonscript.util'
     end)

   1 local _cache = {}

     -- find the line number of `pos` chars into fname
     local lookup_line = function(fname, pos)
***0   if not _cache[fname] then
***0     local f = io.open(fname)
***0     _cache[fname] = f:read('*a')
***0     f:close()
       end

***0   return util.pos_to_line(_cache[fname], pos)
     end

     local rewrite_linenumber = function(fname, lineno)
***0   local tbl = line_tables['@' .. fname]
***0   if fname and tbl then
***0     for i = lineno, 0 ,-1 do
***0       if tbl[i] then
***0         return lookup_line(fname, tbl[i])
           end
         end
       end

***0   return lineno
     end

     local rewrite_filename = function(filename)
       -- sometimes moonscript gives files like [string "./filename.moon"], so
       -- we'll chop it up to only get the filename.
***0   return filename:match('string "(.+)"') or filename
     end

     local rewrite_traceback = function(fname, trace)
       local rewrite_one = function(line, pattern, sub)
***0     if line == nil then return '' end

***0     local fname, lineno = line:match(pattern)

***0     if fname and lineno then
***0       fname = rewrite_filename(fname)
***0       local new_lineno = rewrite_linenumber(fname, tonumber(lineno))
***0       if new_lineno then
***0         line = line:gsub(sub:format(tonumber(lineno)), sub:format(tonumber(new_lineno)))
           end
         end

***0     return line
       end

***0   local lines = {}
***0   local j = 0

***0   for line in trace:gmatch('[^\r\n]+') do
***0     j = j + 1
***0     line = rewrite_one(line, '%s*(.-):(%d+): ', ':%d:')
***0     line = rewrite_one(line, '<(.*):(%d+)>', ':%d>')
***0     lines[j] = line
       end

***0   return '\n' .. table.concat(lines, trace:match('[\r\n]+')) .. '\n'
     end

   1 local ret = {}

     local getTrace = function(filename, info)
***0   local index = info.traceback:find('\n%s*%[C]')
***0   info.traceback = info.traceback:sub(1, index)

***0   info.short_src = rewrite_filename(info.short_src)
***0   info.traceback = rewrite_traceback(filename, info.traceback)
***0   info.linedefined = rewrite_linenumber(filename, info.linedefined)
***0   info.currentline = rewrite_linenumber(filename, info.currentline)

***0   return info
     end

     local rewriteMessage = function(filename, message)
***0   local fname, line, msg = message:match('^([^\n]-):(%d+): (.*)')
***0   if not fname then
***0     return message
       end

***0   fname = rewrite_filename(fname)
***0   line = rewrite_linenumber(fname, tonumber(line))

***0   return fname .. ':' .. tostring(line) .. ': ' .. msg
     end

     ret.match = function(busted, filename)
***0   return ok and path.extension(filename) == '.moon'
     end

     ret.load = function(busted, filename)
***0   local file, err = moonscript.loadfile(filename)
***0   if not file then
***0     busted.publish({ 'error', 'file' }, { descriptor = 'file', name = filename }, nil, err, {})
       end
***0   return file, getTrace, rewriteMessage
     end

   1 return ret

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/modules/filter_loader.lua
==============================================================================
     return function()
       local function filter(busted, options)
         local getFullName = function(name)
***0       local parent = busted.context.get()
***0       local names = { name }

***0       while parent and (parent.name or parent.descriptor) and
***0             parent.descriptor ~= 'file' do
***0         table.insert(names, 1, parent.name or parent.descriptor)
***0         parent = busted.context.parent(parent)
           end

***0       return table.concat(names, ' ')
         end

         local hasTag = function(name, tag)
***0       local found = name:find('#' .. tag)
***0       return (found ~= nil)
         end

         local filterExcludeTags = function(name)
***0       for i, tag in pairs(options.excludeTags) do
***0         if hasTag(name, tag) then
***0           return nil, false
             end
           end
***0       return nil, true
         end

         local filterTags = function(name)
***0       local fullname = getFullName(name)
***0       for i, tag in pairs(options.tags) do
***0         if hasTag(fullname, tag) then
***0           return nil, true
             end
           end
***0       return nil, (#options.tags == 0)
         end

         local filterOutNames = function(name)
***0       for _, filter in pairs(options.filterOut) do
***0         if getFullName(name):find(filter) ~= nil then
***0           return nil, false
             end
           end
***0       return nil, true
         end

   1     local excludeNames = {}
   1     if options.excludeNamesFile then
***0       for name in io.lines(options.excludeNamesFile) do
***0         table.insert(excludeNames, name)
           end
         end

         local excludeNamesFile = function(name)
***0       for _, filter in ipairs(excludeNames) do
***0         if getFullName(name) == filter then
***0           return nil, false
             end
           end
***0       return nil, true
         end

         local name = function(name)
***0       for _, candidate in pairs(options.name) do
***0         if string.find(candidate, getFullName(name), 1, true) then
***0           return nil, true
             end
           end
***0       return nil, (#options.name == 0)
         end

         local filterNames = function(name)
***0       for _, filter in pairs(options.filter) do
***0         if getFullName(name):find(filter) ~= nil then
***0           return nil, true
             end
           end
***0       return nil, (#options.filter == 0)
         end

         local printTestName = function(element, parent, status)
***0       if not (options.suppressPending and status == 'pending') then
***0         local fullname = getFullName()
***0         local trace = element.trace
***0         if trace and trace.what == 'Lua' then
***0           fullname = trace.short_src .. ':' .. trace.currentline .. ': ' .. fullname
             end
***0         print(fullname)
           end
***0       return nil, false
         end

         local ignoreAll = function()
***0       return nil, false
         end

   1     local noop = function() end
         local stubOut = function(descriptor, name, fn, ...)
***0       if fn == noop then
***0         return nil, true
           end
***0       busted.publish({ 'register', descriptor }, name, noop, ...)
***0       return nil, false
         end

         local skipOnError = function()
***0       return nil, not busted.skipAll
         end

         local applyFilter = function(descriptors, name, fn)
  10       if options[name] and options[name] ~= '' then
  18         for _, descriptor in ipairs(descriptors) do
  13           busted.subscribe({ 'register', descriptor }, fn, { priority = 1 })
             end
           end
         end

         local applyDescFilter = function(descriptors, name, fn)
***0       if options[name] and options[name] ~= '' then
***0         for _, descriptor in ipairs(descriptors) do
***0           local f = function(...) return fn(descriptor, ...) end
***0           busted.subscribe({ 'register', descriptor }, f, { priority = 1 })
             end
           end
         end

   1     if options.list then
***0       busted.subscribe({ 'suite', 'start' }, ignoreAll, { priority = 1 })
***0       busted.subscribe({ 'suite', 'end' }, ignoreAll, { priority = 1 })
***0       busted.subscribe({ 'file', 'start' }, ignoreAll, { priority = 1 })
***0       busted.subscribe({ 'file', 'end' }, ignoreAll, { priority = 1 })
***0       busted.subscribe({ 'describe', 'start' }, ignoreAll, { priority = 1 })
***0       busted.subscribe({ 'describe', 'end' }, ignoreAll, { priority = 1 })
***0       busted.subscribe({ 'test', 'start' }, ignoreAll, { priority = 1 })
***0       busted.subscribe({ 'test', 'end' }, printTestName, { priority = 1 })
***0       applyDescFilter({ 'setup', 'teardown', 'before_each', 'after_each' }, 'list', stubOut)
***0       applyDescFilter({ 'lazy_setup', 'lazy_teardown' }, 'list', stubOut)
***0       applyDescFilter({ 'strict_setup', 'strict_teardown' }, 'list', stubOut)
***0       applyDescFilter({ 'it', 'pending' }, 'list', stubOut)
         end

   1     applyFilter({ 'lazy_setup', 'lazy_teardown' }, 'nokeepgoing', skipOnError)
   1     applyFilter({ 'strict_setup', 'strict_teardown' }, 'nokeepgoing', skipOnError)
   1     applyFilter({ 'setup', 'teardown', 'before_each', 'after_each' }, 'nokeepgoing', skipOnError)
   1     applyFilter({ 'file', 'describe', 'it', 'pending' }, 'nokeepgoing', skipOnError)

         -- The following filters are applied in reverse order
   1     applyFilter({ 'it', 'pending' }            , 'filter'          , filterNames           )
   1     applyFilter({ 'describe', 'it', 'pending' }, 'name'            , name                  )
   1     applyFilter({ 'describe', 'it', 'pending' }, 'filterOut'       , filterOutNames        )
   1     applyFilter({ 'describe', 'it', 'pending' }, 'excludeNamesFile', excludeNamesFile      )
   1     applyFilter({ 'it', 'pending' }            , 'tags'            , filterTags            )
   1     applyFilter({ 'describe', 'it', 'pending' }, 'excludeTags'     , filterExcludeTags     )
       end

***0   return filter
     end

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/modules/output_handler_loader.lua
==============================================================================
***0 local path = require 'pl.path'
***0 local hasMoon, moonscript = pcall(require, 'moonscript')
***0 local utils = require 'busted.utils'

     return function()
       local loadOutputHandler = function(busted, output, options)
         local handler

   1     utils.copy_interpreter_args(options.arguments)
   2     local success, err = pcall(function()
   1       if output:match('%.lua$') then
***0         handler = dofile(path.normpath(output))
   1       elseif hasMoon and output:match('%.moon$') then
***0         handler = moonscript.dofile(path.normpath(output))
           else
   1         handler = require('busted.outputHandlers.' .. output)
           end
         end)

   1     if not success and err:match("module '.-' not found:") then
***0       success, err = pcall(function() handler = require(output) end)
         end

   1     if not success then
***0       busted.publish({ 'error', 'output' }, { descriptor = 'output', name = output }, nil, err, {})
***0       handler = require('busted.outputHandlers.' .. options.defaultOutput)
         end

   1     if options.enableSound then
***0       require 'busted.outputHandlers.sound'(options)
         end

   2     handler(options):subscribe(options)
       end

***0   return loadOutputHandler
     end

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/modules/test_file_loader.lua
==============================================================================
   1 local s = require 'say'

     return function(busted, loaders)
   1   local path = require 'pl.path'
   1   local dir = require 'pl.dir'
   1   local tablex = require 'pl.tablex'
   1   local fileLoaders = {}

   3   for _, v in pairs(loaders) do
   2     local loader = require('busted.modules.files.'..v)
   2     fileLoaders[#fileLoaders+1] = loader
       end

       local getTestFiles = function(rootFile, patterns, options)
         local fileList

   2     if path.isfile(rootFile) then
***0       fileList = { rootFile }
   2     elseif path.isdir(rootFile) then
   1       local getfiles = options.recursive and dir.getallfiles or dir.getfiles
   2       fileList = getfiles(rootFile)

   2       fileList = tablex.filter(fileList, function(filename)
   1         local basename = path.basename(filename)
   1         for _, patt in ipairs(options.excludes) do
***0           if patt ~= '' and basename:find(patt) then
***0             return nil
               end
             end
   1         for _, patt in ipairs(patterns) do
   1           if basename:find(patt) then
   1             return true
               end
             end
***0         return #patterns == 0
           end)

   2       fileList = tablex.filter(fileList, function(filename)
   1         if path.is_windows then
***0           return not filename:find('%\\%.%w+.%w+', #rootFile)
             else
   1           return not filename:find('/%.%w+.%w+', #rootFile)
             end
           end)
         else
***0       busted.publish({ 'error' }, {}, nil, s('output.file_not_found'):format(rootFile), {})
***0       fileList = {}
         end

   1     table.sort(fileList)
   1     return fileList
       end

       local getAllTestFiles = function(rootFiles, patterns, options)
   1     local fileList = {}
   2     for _, root in ipairs(rootFiles) do
   2       tablex.insertvalues(fileList, getTestFiles(root, patterns, options))
         end
   1     return fileList
       end

       -- runs a testfile, loading its tests
       local loadTestFile = function(busted, filename)
   1     for _, v in pairs(fileLoaders) do
   2       if v.match(busted, filename) then
   1         return v.load(busted, filename)
           end
         end
       end

       local loadTestFiles = function(rootFiles, patterns, options)
   1     local fileList = getAllTestFiles(rootFiles, patterns, options)

   2     for i, fileName in ipairs(fileList) do
   1       local testFile, getTrace, rewriteMessage = loadTestFile(busted, fileName)

   1       if testFile then
   2         local file = setmetatable({
   1           getTrace = getTrace,
   1           rewriteMessage = rewriteMessage
   1         }, {
   1           __call = testFile
             })

   1         busted.executors.file(fileName, file)
           end
         end

   1     if #fileList == 0 then
***0       local pattern = patterns[1]
***0       if #patterns > 1 then
***0         pattern = '\n\t' .. table.concat(patterns, '\n\t')
           end
***0       busted.publish({ 'error' }, {}, nil, s('output.no_test_files_match'):format(pattern), {})
         end

   1     return fileList
       end

   1   return loadTestFiles, loadTestFile, getAllTestFiles
     end


==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/outputHandlers/TAP.lua
==============================================================================
   1 local pretty = require 'pl.pretty'
   1 local io = io
   1 local type = type
   1 local string_format = string.format
   1 local string_gsub = string.gsub
   1 local io_write = io.write
   1 local io_flush = io.flush

     local function print(msg)
   1   io_write(msg .. '\n')
     end

     return function(options)
   1   local busted = require 'busted'
   1   local handler = require 'busted.outputHandlers.base'()

   1   local success = 'ok %u - %s'
   1   local failure = 'not ' .. success
   1   local skip = 'ok %u - # SKIP %s'
   1   local counter = 0

       handler.suiteReset = function()
***0     counter = 0
***0     return nil, true
       end

       handler.suiteEnd = function()
   1     print('1..' .. counter)
   1     io_flush()
   1     return nil, true
       end

       local function showFailure(t)
***0     local message = t.message
***0     local trace = t.trace or {}

***0     if message == nil then
***0       message = 'Nil error'
***0     elseif type(message) ~= 'string' then
***0       message = pretty.write(message)
         end

***0     print(string_format(failure, counter, t.name))
***0     if t.element.trace.short_src then
***0       print('# ' .. t.element.trace.short_src .. ' @ ' .. t.element.trace.currentline)
         end
***0     if t.randomseed then
***0       print('# Random seed: ' .. t.randomseed)
         end
***0     print('# Failure message: ' .. string_gsub(message, '\n', '\n# '))
***0     if options.verbose and trace.traceback then
***0       print('# ' .. string_gsub(string_gsub(trace.traceback, '^\n', '', 1), '\n', '\n# '))
         end
       end

       handler.testStart = function(element, parent)
***0     local trace = element.trace
***0     if options.verbose and trace and trace.short_src then
***0       local fileline = trace.short_src .. ' @ ' ..  trace.currentline .. ': '
***0       local testName = fileline .. handler.getFullName(element)
***0       print('# ' .. testName)
         end
***0     io.flush()

***0     return nil, true
       end

       handler.testEnd = function(element, parent, status, trace)
***0     counter = counter + 1
***0     if status == 'success' then
***0       local t = handler.successes[#handler.successes]
***0       print(string_format(success, counter, t.name))
***0     elseif status == 'pending' then
***0       local t = handler.pendings[#handler.pendings]
***0       print(string_format(skip, counter, (t.message or t.name)))
***0     elseif status == 'failure' then
***0       showFailure(handler.failures[#handler.failures])
***0     elseif status == 'error' then
***0       showFailure(handler.errors[#handler.errors])
         end
***0     io.flush()

***0     return nil, true
       end

       handler.error = function(element, parent, message, debug)
***0     if element.descriptor ~= 'it' then
***0       counter = counter + 1
***0       showFailure(handler.errors[#handler.errors])
         end
***0     io.flush()

***0     return nil, true
       end

   2   busted.subscribe({ 'suite', 'reset' }, handler.suiteReset)
   2   busted.subscribe({ 'suite', 'end' }, handler.suiteEnd)
   2   busted.subscribe({ 'test', 'start' }, handler.testStart, { predicate = handler.cancelOnPending })
   2   busted.subscribe({ 'test', 'end' }, handler.testEnd, { predicate = handler.cancelOnPending })
   2   busted.subscribe({ 'error' }, handler.error)

   1   return handler
     end

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/outputHandlers/base.lua
==============================================================================
   1 local table_concat = table.concat
   1 local table_insert = table.insert

     return function()
   1   local busted = require 'busted'
   1   local handler = {
   1     successes = {},
         successesCount = 0,
   1     pendings = {},
         pendingsCount = 0,
   1     failures = {},
         failuresCount = 0,
   1     errors = {},
         errorsCount = 0,
   1     inProgress = {}
       }

       handler.cancelOnPending = function(element, parent, status)
***0     return not ((element.descriptor == 'pending' or status == 'pending') and handler.options.suppressPending)
       end

       handler.subscribe = function(handler, options)
   1     require('busted.languages.en')
   1     handler.options = options

   1     if options.language ~= 'en' then
***0       require('busted.languages.' .. options.language)
         end

   2     busted.subscribe({ 'suite', 'reset' }, handler.baseSuiteReset, { priority = 1 })
   2     busted.subscribe({ 'suite', 'start' }, handler.baseSuiteStart, { priority = 1 })
   2     busted.subscribe({ 'suite', 'end' }, handler.baseSuiteEnd, { priority = 1 })
   2     busted.subscribe({ 'test', 'start' }, handler.baseTestStart, { priority = 1, predicate = handler.cancelOnPending })
   2     busted.subscribe({ 'test', 'end' }, handler.baseTestEnd, { priority = 1, predicate = handler.cancelOnPending })
   2     busted.subscribe({ 'pending' }, handler.basePending, { priority = 1, predicate = handler.cancelOnPending })
   2     busted.subscribe({ 'failure', 'it' }, handler.baseTestFailure, { priority = 1 })
   2     busted.subscribe({ 'error', 'it' }, handler.baseTestError, { priority = 1 })
   2     busted.subscribe({ 'failure' }, handler.baseError, { priority = 1 })
   2     busted.subscribe({ 'error' }, handler.baseError, { priority = 1 })
       end

       handler.getFullName = function(context)
***0     local parent = busted.parent(context)
***0     local names = { (context.name or context.descriptor) }

***0     while parent and (parent.name or parent.descriptor) and
***0           parent.descriptor ~= 'file' do

***0       table_insert(names, 1, parent.name or parent.descriptor)
***0       parent = busted.parent(parent)
         end

***0     return table_concat(names, ' ')
       end

       handler.format = function(element, parent, message, debug, isError)
         local function copyElement(e)
***0       local copy = {}
***0       for k,v in next, e do
***0         if type(v) ~= 'function' and k ~= 'env' then
***0           copy[k] = v
             end
           end
***0       return copy
         end

***0     local formatted = {
           trace = debug or element.trace,
           element = copyElement(element),
           name = handler.getFullName(element),
           message = message,
           randomseed = parent and parent.randomseed,
***0       isError = isError
         }
***0     formatted.element.trace = element.trace or debug

***0     return formatted
       end

       handler.getDuration = function()
***0     if not handler.endTick or not handler.startTick then
***0       return 0
         end

***0     return handler.endTick - handler.startTick
       end

       handler.baseSuiteStart = function(suite)
   1     handler.startTick = suite.starttick
   1     handler.startTime = suite.starttime
   1     return nil, true
       end

       handler.baseSuiteReset = function()
***0     handler.successes = {}
***0     handler.successesCount = 0
***0     handler.pendings = {}
***0     handler.pendingsCount = 0
***0     handler.failures = {}
***0     handler.failuresCount = 0
***0     handler.errors = {}
***0     handler.errorsCount = 0
***0     handler.inProgress = {}

***0     return nil, true
       end

       handler.baseSuiteEnd = function(suite)
   1     handler.endTick = suite.endtick
   1     handler.endTime = suite.endtime
   1     return nil, true
       end

       handler.baseTestStart = function(element, parent)
***0     handler.inProgress[tostring(element)] = {}
***0     return nil, true
       end

       handler.baseTestEnd = function(element, parent, status, debug)
         local insertTable

***0     if status == 'success' then
***0       insertTable = handler.successes
***0       handler.successesCount = handler.successesCount + 1
***0     elseif status == 'pending' then
***0       insertTable = handler.pendings
***0       handler.pendingsCount = handler.pendingsCount + 1
***0     elseif status == 'failure' then
           -- failure already saved in failure handler
***0       handler.failuresCount = handler.failuresCount + 1
***0       return nil, true
***0     elseif status == 'error' then
           -- error count already incremented and saved in error handler
***0       return nil, true
         end

***0     local formatted = handler.format(element, parent, element.message, debug)

***0     local id = tostring(element)
***0     if handler.inProgress[id] then
***0       for k, v in pairs(handler.inProgress[id]) do
***0         formatted[k] = v
           end

***0       handler.inProgress[id] = nil
         end

***0     table_insert(insertTable, formatted)

***0     return nil, true
       end

       handler.basePending = function(element, parent, message, debug)
***0     local id = tostring(element)
***0     handler.inProgress[id].message = message
***0     handler.inProgress[id].trace = debug
***0     return nil, true
       end

       handler.baseTestFailure = function(element, parent, message, debug)
***0     table_insert(handler.failures, handler.format(element, parent, message, debug))
***0     return nil, true
       end

       handler.baseTestError = function(element, parent, message, debug)
***0     handler.errorsCount = handler.errorsCount + 1
***0     table_insert(handler.errors, handler.format(element, parent, message, debug, true))
***0     return nil, true
       end

       handler.baseError = function(element, parent, message, debug)
***0     if element.descriptor ~= 'it' then
***0       handler.errorsCount = handler.errorsCount + 1
***0       table_insert(handler.errors, handler.format(element, parent, message, debug, true))
         end

***0     return nil, true
       end

   1   return handler
     end

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/outputHandlers/vusted/default.lua
==============================================================================
     return function(options)
   1   local busted = require("busted")
   1   local handler = require("busted.outputHandlers.TAP")(options)

       -- avoid using print not to affect message history.
   1   local write = io.write

       local suite_start = function(suite)
   1     if suite.randomseed then
           -- NOTE: can know random seed even if neovim crashes
***0       write(("# Random seed: %s\n"):format(suite.randomseed))
         end
   1     return nil, true
       end
   2   busted.subscribe({ "suite", "start" }, suite_start)

       local test_path = function(t)
***0     local trace = t.element.trace
***0     if not (trace and trace.source) then
***0       return nil
         end
***0     local source = trace.source:gsub("^@", "")
***0     return ("%s:%d : %s"):format(source, trace.currentline, t.name)
       end

       local show_test_paths = function(tests)
***0     for _, test in ipairs(tests) do
***0       local path = test_path(test)
***0       if path then
***0         write(("#   %s\n"):format(path))
           end
         end
       end

       local show_slows = function(tests)
   1     local env_threshold = os.getenv("VUSTED_SLOW_MS")
   1     if not env_threshold then
   1       return
         end
***0     local threshold = tonumber(env_threshold)

***0     local slows = {}
***0     for _, t in ipairs(tests) do
***0       local ms = t.element.duration * 1000
***0       if ms >= threshold then
***0         table.insert(slows, { duration = ms, path = test_path(t) })
           end
         end
***0     if #slows == 0 then
***0       return
         end

***0     table.sort(slows, function(a, b)
***0       return a.duration > b.duration
         end)

***0     write(("# Slow: %d (threshold: %.2f ms)\n"):format(#slows, threshold))
***0     for _, slow in ipairs(slows) do
***0       write(("#   %s (%.2f ms)\n"):format(slow.path, slow.duration))
         end
       end

       local suite_end = function()
   1     write("\n\n")

   1     write(("# Success: %d\n"):format(#handler.successes))

   1     if #handler.failures > 0 then
***0       write(("# Failure: %d\n"):format(#handler.failures))
***0       show_test_paths(handler.failures)
         end

   1     if #handler.pendings > 0 then
***0       write(("# Pending: %d\n"):format(#handler.pendings))
***0       show_test_paths(handler.pendings)
         end

   1     if #handler.errors > 0 then
***0       write(("# Error: %d\n"):format(#handler.errors))
***0       show_test_paths(handler.errors)
         end

   1     show_slows(handler.successes)

   1     return nil, true
       end
   2   busted.subscribe({ "suite", "end" }, suite_end)

   1   return handler
     end

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/runner.lua
==============================================================================
     -- Busted command-line runner

***0 local path = require 'pl.path'
***0 local tablex = require 'pl.tablex'
***0 local term = require 'term'
***0 local utils = require 'busted.utils'
***0 local exit = require 'busted.compatibility'.exit
***0 local loadstring = require 'busted.compatibility'.loadstring
***0 local loaded = false

     return function(options)
***0   if loaded then return function() end else loaded = true end

***0   local isatty = io.type(io.stdout) == 'file' and term.isatty(io.stdout)
***0   options = tablex.update(require 'busted.options', options or {})
***0   options.output = options.output or (isatty and 'utfTerminal' or 'plainTerminal')

***0   local busted = require 'busted.core'()

***0   local cli = require 'busted.modules.cli'(options)
***0   local filterLoader = require 'busted.modules.filter_loader'()
***0   local helperLoader = require 'busted.modules.helper_loader'()
***0   local outputHandlerLoader = require 'busted.modules.output_handler_loader'()

***0   local luacov = require 'busted.modules.luacov'()

***0   require 'busted'(busted)

***0   local level = 2
***0   local info = debug.getinfo(level, 'Sf')
***0   local source = info.source
***0   local fileName = source:sub(1,1) == '@' and source:sub(2) or nil
***0   local forceExit = fileName == nil

       -- Parse the cli arguments
***0   local appName = path.basename(fileName or 'busted')
***0   cli:set_name(appName)
***0   local cliArgs, err = cli:parse(arg)
***0   if not cliArgs then
***0     io.stderr:write(err .. '\n')
***0     exit(1, forceExit)
       end

***0   if cliArgs.version then
         -- Return early if asked for the version
***0     print(busted.version)
***0     exit(0, forceExit)
       end

       -- Load current working directory
***0   local _, err = path.chdir(path.normpath(cliArgs.directory))
***0   if err then
***0     io.stderr:write(appName .. ': error: ' .. err .. '\n')
***0     exit(1, forceExit)
       end

       -- If coverage arg is passed in, load LuaCovsupport
***0   if cliArgs.coverage then
***0     local ok, err = luacov(cliArgs['coverage-config-file'])
   1     if not ok then
***0       io.stderr:write(appName .. ': error: ' .. err .. '\n')
***0       exit(1, forceExit)
         end
       end

       -- If auto-insulate is disabled, re-register file without insulation
   1   if not cliArgs['auto-insulate'] then
***0     busted.register('file', 'file', {})
       end

       -- If lazy is enabled, make lazy setup/teardown the default
   1   if cliArgs.lazy then
***0     busted.register('setup', 'lazy_setup')
***0     busted.register('teardown', 'lazy_teardown')
       end

       -- Add additional package paths based on lpath and cpath cliArgs
   1   if #cliArgs.lpath > 0 then
   1     package.path = (cliArgs.lpath .. ';' .. package.path):gsub(';;',';')
       end

   1   if #cliArgs.cpath > 0 then
   1     package.cpath = (cliArgs.cpath .. ';' .. package.cpath):gsub(';;',';')
       end

       -- Load and execute commands given on the command-line
   1   if cliArgs.e then
   1     for k,v in ipairs(cliArgs.e) do
***0       loadstring(v)()
         end
       end

       -- watch for test errors and failures
   1   local failures = 0
   1   local errors = 0
   1   local quitOnError = not cliArgs['keep-going']

   2   busted.subscribe({ 'error', 'output' }, function(element, parent, message)
***0     io.stderr:write(appName .. ': error: Cannot load output library: ' .. element.name .. '\n' .. message .. '\n')
***0     return nil, true
       end)

   2   busted.subscribe({ 'error', 'helper' }, function(element, parent, message)
***0     io.stderr:write(appName .. ': error: Cannot load helper script: ' .. element.name .. '\n' .. message .. '\n')
***0     return nil, true
       end)

   2   busted.subscribe({ 'error' }, function(element, parent, message)
***0     errors = errors + 1
***0     busted.skipAll = quitOnError
***0     return nil, true
       end)

   2   busted.subscribe({ 'failure' }, function(element, parent, message)
***0     if element.descriptor == 'it' then
***0       failures = failures + 1
         else
***0       errors = errors + 1
         end
***0     busted.skipAll = quitOnError
***0     return nil, true
       end)

       -- Set up randomization options
   1   busted.sort = cliArgs['sort-tests']
   1   busted.randomize = cliArgs['shuffle-tests']
   2   busted.randomseed = tonumber(cliArgs.seed) or utils.urandom() or os.time()

       -- Set up output handler to listen to events
   2   outputHandlerLoader(busted, cliArgs.output, {
   1     defaultOutput = options.output,
   1     enableSound = cliArgs['enable-sound'],
   1     verbose = cliArgs.verbose,
   1     suppressPending = cliArgs['suppress-pending'],
   1     language = cliArgs.lang,
   1     deferPrint = cliArgs['defer-print'],
   1     arguments = cliArgs.Xoutput,
       })

       -- Pre-load the LuaJIT 'ffi' module if applicable
   1   require 'busted.luajit'()

       -- Set up helper script, must succeed to even start tests
   1   if cliArgs.helper and cliArgs.helper ~= '' then
***0     local ok, err = helperLoader(busted, cliArgs.helper, {
           verbose = cliArgs.verbose,
           language = cliArgs.lang,
***0       arguments = cliArgs.Xhelper
         })
***0     if not ok then
***0       io.stderr:write(appName .. ': failed running the specified helper (' ..
***0                       cliArgs.helper .. '), error: ' .. err .. '\n')
***0       exit(1, forceExit)
         end
       end

       local getFullName = function(name)
***0     local parent = busted.context.get()
***0     local names = { name }

***0     while parent and (parent.name or parent.descriptor) and
***0       parent.descriptor ~= 'file' do
***0       table.insert(names, 1, parent.name or parent.descriptor)
***0       parent = busted.context.parent(parent)
         end

***0     return table.concat(names, ' ')
       end

   1   if cliArgs['log-success'] then
***0     local logFile = assert(io.open(cliArgs['log-success'], 'a'))
***0     busted.subscribe({ 'test', 'end' }, function (test, parent, status)
***0       if status == "success" then
***0         logFile:write(getFullName() .. "\n")
           end
         end)
       end

       -- Load tag and test filters
   2   filterLoader(busted, {
   1     tags = cliArgs.tags,
   1     excludeTags = cliArgs['exclude-tags'],
   1     filter = cliArgs.filter,
   1     name = cliArgs.name,
   1     filterOut = cliArgs['filter-out'],
   1     excludeNamesFile = cliArgs['exclude-names-file'],
   1     list = cliArgs.list,
   1     nokeepgoing = not cliArgs['keep-going'],
   1     suppressPending = cliArgs['suppress-pending'],
       })

   1   if cliArgs.ROOT then
         -- Load test directories/files
   1     local rootFiles = cliArgs.ROOT
   1     local patterns = cliArgs.pattern
   1     local testFileLoader = require 'busted.modules.test_file_loader'(busted, cliArgs.loaders)
   2     testFileLoader(rootFiles, patterns, {
   1       excludes = cliArgs['exclude-pattern'],
   1       verbose = cliArgs.verbose,
   1       recursive = cliArgs['recursive'],
   1     })
       else
         -- Running standalone, use standalone loader
***0     local testFileLoader = require 'busted.modules.standalone_loader'(busted)
***0     testFileLoader(info, { verbose = cliArgs.verbose })
       end

   1   local runs = cliArgs['repeat']
   1   local execute = require 'busted.execute'(busted)
   2   execute(runs, {
   1     seed = cliArgs.seed,
   1     shuffle = cliArgs['shuffle-files'],
   1     sort = cliArgs['sort-files'],
       })

   1   busted.publish({ 'exit' })

   1   if options.standalone or failures > 0 or errors > 0 then
***0     exit(failures + errors, forceExit)
       end
     end

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/status.lua
==============================================================================
     local function get_status(status)
   6   local smap = {
         ['success'] = 'success',
         ['pending'] = 'pending',
         ['failure'] = 'failure',
         ['error'] = 'error',
         ['true'] = 'success',
         ['false'] = 'failure',
         ['nil'] = 'error',
       }
   6   return smap[tostring(status)] or 'error'
     end

     return function(inital_status)
   6   local objstat = get_status(inital_status)
   6   local obj = {
  11     success = function(self) return (objstat == 'success') end,
   6     pending = function(self) return (objstat == 'pending') end,
   6     failure = function(self) return (objstat == 'failure') end,
   6     error   = function(self) return (objstat == 'error') end,

         get = function(self)
***0       return objstat
         end,

         set = function(self, status)
***0       objstat = get_status(status)
         end,

         update = function(self, status)
           -- prefer current failure/error status over new status
***0       status = get_status(status)
***0       if objstat == 'success' or (objstat == 'pending' and status ~= 'success') then
***0         objstat = status
           end
         end
       }

   6   return setmetatable(obj, {
   6     __index = {},
   6     __tostring = function(self) return objstat end
   6   })
     end

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/utils.lua
==============================================================================
***0 return {
       copy_interpreter_args = function(arguments)
         -- copy non-positive command-line args auto-inserted by Lua interpreter
   1     if arguments and _G.arg then
   1       local i = 0
   1       while _G.arg[i] do
***0         arguments[i] = _G.arg[i]
***0         i = i - 1
           end
         end
       end,

       split = require 'pl.utils'.split,

       shuffle = function(t, seed)
***0     if seed then math.randomseed(seed) end
***0     local n = #t
***0     while n >= 2 do
***0       local k = math.random(n)
***0       t[n], t[k] = t[k], t[n]
***0       n = n - 1
         end
***0     return t
       end,

       urandom = function()
   1     local f = io.open('/dev/urandom', 'rb')
   1     if not f then return nil end
   1     local s = f:read(4) f:close()
   1     local bytes = {s:byte(1, 4)}
   1     local value = 0
   5     for _, v in ipairs(bytes) do
   4       value = value * 256 + v
         end
   1     return value
       end,
     }

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/luassert/assert.lua
==============================================================================
***0 local s = require 'say'
***0 local astate = require 'luassert.state'
***0 local util = require 'luassert.util'
***0 local unpack = util.unpack
     local obj   -- the returned module table
***0 local level_mt = {}

     -- list of namespaces
***0 local namespace = require 'luassert.namespaces'

     local function geterror(assertion_message, failure_message, args)
***0   if util.hastostring(failure_message) then
***0     failure_message = tostring(failure_message)
***0   elseif failure_message ~= nil then
***0     failure_message = astate.format_argument(failure_message)
       end
***0   local message = s(assertion_message, obj:format(args))
***0   if message and failure_message then
***0     message = failure_message .. "\n" .. message
       end
***0   return message or failure_message
     end

***0 local __state_meta = {

       __call = function(self, ...)
***0     local keys = util.extract_keys("assertion", self.tokens)

         local assertion

***0     for _, key in ipairs(keys) do
***0       assertion = namespace.assertion[key] or assertion
         end

***0     if assertion then
***0       for _, key in ipairs(keys) do
***0         if namespace.modifier[key] then
***0           namespace.modifier[key].callback(self)
             end
           end

***0       local arguments = util.make_arglist(...)
***0       local val, retargs = assertion.callback(self, arguments, util.errorlevel())

***0       if (not val) == self.mod then
***0         local message = assertion.positive_message
***0         if not self.mod then
***0           message = assertion.negative_message
             end
***0         local err = geterror(message, rawget(self,"failure_message"), arguments)
***0         error(err or "assertion failed!", util.errorlevel())
           end

***0       if retargs then
***0         return unpack(retargs)
           end
***0       return ...
         else
***0       local arguments = util.make_arglist(...)
***0       self.tokens = {}

***0       for _, key in ipairs(keys) do
***0         if namespace.modifier[key] then
***0           namespace.modifier[key].callback(self, arguments, util.errorlevel())
             end
           end
         end

***0     return self
       end,

       __index = function(self, key)
***0     for token in key:lower():gmatch('[^_]+') do
***0       table.insert(self.tokens, token)
         end

***0     return self
       end
     }

***0 obj = {
       state = function() return setmetatable({mod=true, tokens={}}, __state_meta) end,

       -- registers a function in namespace
       register = function(self, nspace, name, callback, positive_message, negative_message)
***0     local lowername = name:lower()
***0     if not namespace[nspace] then
***0       namespace[nspace] = {}
         end
***0     namespace[nspace][lowername] = {
           callback = callback,
           name = lowername,
           positive_message=positive_message,
***0       negative_message=negative_message
         }
       end,

       -- unregisters a function in a namespace
       unregister = function(self, nspace, name)
***0     local lowername = name:lower()
***0     if not namespace[nspace] then
***0       namespace[nspace] = {}
         end
***0     namespace[nspace][lowername] = nil
       end,

       -- registers a formatter
       -- a formatter takes a single argument, and converts it to a string, or returns nil if it cannot format the argument
       add_formatter = function(self, callback)
***0     astate.add_formatter(callback)
       end,

       -- unregisters a formatter
       remove_formatter = function(self, fmtr)
***0     astate.remove_formatter(fmtr)
       end,

       format = function(self, args)
         -- args.n specifies the number of arguments in case of 'trailing nil' arguments which get lost
***0     local nofmt = args.nofmt or {}  -- arguments in this list should not be formatted
***0     local fmtargs = args.fmtargs or {} -- additional arguments to be passed to formatter
***0     for i = 1, (args.n or #args) do -- cannot use pairs because table might have nils
***0       if not nofmt[i] then
***0         local val = args[i]
***0         local valfmt = astate.format_argument(val, nil, fmtargs[i])
***0         if valfmt == nil then valfmt = tostring(val) end -- no formatter found
***0         args[i] = valfmt
           end
         end
***0     return args
       end,

       set_parameter = function(self, name, value)
***0     astate.set_parameter(name, value)
       end,

       get_parameter = function(self, name)
***0     return astate.get_parameter(name)
       end,

       add_spy = function(self, spy)
***0     astate.add_spy(spy)
       end,

       snapshot = function(self)
***0     return astate.snapshot()
       end,

       level = function(self, level)
***0     return setmetatable({
***0         level = level
***0       }, level_mt)
       end,

       -- returns the level if a level-value, otherwise nil
       get_level = function(self, level)
***0     if getmetatable(level) ~= level_mt then
***0       return nil -- not a valid error-level
         end
***0     return level.level
       end,
     }

***0 local __meta = {

       __call = function(self, bool, message, level, ...)
   1     if not bool then
***0       local err_level = (self:get_level(level) or 1) + 1
***0       error(message or "assertion failed!", err_level)
         end
   1     return bool , message , level , ...
       end,

       __index = function(self, key)
***0     return rawget(self, key) or self.state()[key]
       end,

     }

***0 return setmetatable(obj, __meta)

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/mediator.lua
==============================================================================
     local function getUniqueId(obj)
  34   return tonumber(tostring(obj):match(':%s*[0xX]*(%x+)'), 16)
     end

     local function Subscriber(fn, options)
  34   local sub = {
  34     options = options or {},
  34     fn = fn,
         channel = nil,
         update = function(self, options)
***0       if options then
***0         self.fn = options.fn or self.fn
***0         self.options = options.options or self.options
           end
         end
       }
  34   sub.id = getUniqueId(sub)
  34   return sub
     end

     -- Channel class and functions --

     local function Channel(namespace, parent)
  18   return {
         stopped = false,
  18     namespace = namespace,
  18     callbacks = {},
  18     channels = {},
  18     parent = parent,

         addSubscriber = function(self, fn, options)
  34       local callback = Subscriber(fn, options)
  34       local priority = (#self.callbacks + 1)

  34       options = options or {}

  34       if options.priority and
  23         options.priority >= 0 and
  23         options.priority < priority
           then
  20           priority = options.priority
           end

  34       table.insert(self.callbacks, priority, callback)

  34       return callback
         end,

         getSubscriber = function(self, id)
***0       for i=1, #self.callbacks do
***0         local callback = self.callbacks[i]
***0         if callback.id == id then return { index = i, value = callback } end
           end
           local sub
***0       for _, channel in pairs(self.channels) do
***0         sub = channel:getSubscriber(id)
***0         if sub then break end
           end
***0       return sub
         end,

         setPriority = function(self, id, priority)
***0       local callback = self:getSubscriber(id)

***0       if callback.value then
***0         table.remove(self.callbacks, callback.index)
***0         table.insert(self.callbacks, priority, callback.value)
           end
         end,

         addChannel = function(self, namespace)
  36       self.channels[namespace] = Channel(namespace, self)
  18       return self.channels[namespace]
         end,

         hasChannel = function(self, namespace)
***0       return namespace and self.channels[namespace] and true
         end,

         getChannel = function(self, namespace)
  91       return self.channels[namespace] or self:addChannel(namespace)
         end,

         removeSubscriber = function(self, id)
***0       local callback = self:getSubscriber(id)

***0       if callback and callback.value then
***0         for _, channel in pairs(self.channels) do
***0           channel:removeSubscriber(id)
             end

***0         return table.remove(self.callbacks, callback.index)
           end
         end,

         publish = function(self, result, ...)
  20       for i = 1, #self.callbacks do
   6         local callback = self.callbacks[i]

             -- if it doesn't have a predicate, or it does and it's true then run it
   6         if not callback.options.predicate or callback.options.predicate(...) then
                -- just take the first result and insert it into the result table
   6           local value, continue = callback.fn(...)

   6           if value then table.insert(result, value) end
   6           if not continue then return result end
             end
           end

  14       if parent then
   9         return parent:publish(result, ...)
           else
   5         return result
           end
         end
  18   }
     end

     -- Mediator class and functions --

***0 local Mediator = setmetatable(
     {
       Channel = Channel,
***0   Subscriber = Subscriber
     },
     {
       __call = function (fn, options)
***0     return {
           channel = Channel('root'),

           getChannel = function(self, channelNamespace)
  40         local channel = self.channel

 113         for i=1, #channelNamespace do
 146           channel = channel:getChannel(channelNamespace[i])
             end

  40         return channel
           end,

           subscribe = function(self, channelNamespace, fn, options)
  68         return self:getChannel(channelNamespace):addSubscriber(fn, options)
           end,

           getSubscriber = function(self, id, channelNamespace)
***0         return self:getChannel(channelNamespace):getSubscriber(id)
           end,

           removeSubscriber = function(self, id, channelNamespace)
***0         return self:getChannel(channelNamespace):removeSubscriber(id)
           end,

           publish = function(self, channelNamespace, ...)
  12         return self:getChannel(channelNamespace):publish({}, ...)
           end
         }
       end
     })
***0 return Mediator

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/pl/List.lua
==============================================================================
     --- Python-style list class.
     --
     -- **Please Note**: methods that change the list will return the list.
     -- This is to allow for method chaining, but please note that `ls = ls:sort()`
     -- does not mean that a new copy of the list is made. In-place (mutable) methods
     -- are marked as returning 'the list' in this documentation.
     --
     -- See the Guide for further @{02-arrays.md.Python_style_Lists|discussion}
     --
     -- See <a href="http://www.python.org/doc/current/tut/tut.html">http://www.python.org/doc/current/tut/tut.html</a>, section 5.1
     --
     -- **Note**: The comments before some of the functions are from the Python docs
     -- and contain Python code.
     --
     -- Written for Lua version Nick Trout 4.0; Redone for Lua 5.1, Steve Donovan.
     --
     -- Dependencies: `pl.utils`, `pl.tablex`, `pl.class`
     -- @classmod pl.List
     -- @pragma nostrip

   1 local tinsert,tremove,concat,tsort = table.insert,table.remove,table.concat,table.sort
   1 local setmetatable, getmetatable,type,tostring,string = setmetatable,getmetatable,type,tostring,string
   1 local tablex = require 'pl.tablex'
   1 local filter,imap,imap2,reduce,transform,tremovevalues = tablex.filter,tablex.imap,tablex.imap2,tablex.reduce,tablex.transform,tablex.removevalues
   1 local tsub = tablex.sub
   1 local utils = require 'pl.utils'
   1 local class = require 'pl.class'

   1 local array_tostring,split,assert_arg,function_arg = utils.array_tostring,utils.split,utils.assert_arg,utils.function_arg
   1 local normalize_slice = tablex._normalize_slice

     -- metatable for our list and map objects has already been defined..
   1 local Multimap = utils.stdmt.MultiMap
   1 local List = utils.stdmt.List

     local iter

   1 class(nil,nil,List)

     -- we want the result to be _covariant_, i.e. t must have type of obj if possible
     local function makelist (t,obj)
***0     local klass = List
***0     if obj then
***0         klass = getmetatable(obj)
         end
***0     return setmetatable(t,klass)
     end

     local function simple_table(t)
***0     return type(t) == 'table' and not getmetatable(t) and #t > 0
     end

   1 function List._create (src)
***0     if simple_table(src) then return src end
     end

   1 function List:_init (src)
***0     if self == src then return end -- existing table used as self!
***0     if src then
***0         for v in iter(src) do
***0             tinsert(self,v)
             end
         end
     end

     --- Create a new list. Can optionally pass a table;
     -- passing another instance of List will cause a copy to be created;
     -- this will return a plain table with an appropriate metatable.
     -- we pass anything which isn't a simple table to iterate() to work out
     -- an appropriate iterator
     -- @see List.iterate
     -- @param[opt] t An optional list-like table
     -- @return a new List
     -- @usage ls = List();  ls = List {1,2,3,4}
     -- @function List.new

   1 List.new = List

     --- Make a copy of an existing list.
     -- The difference from a plain 'copy constructor' is that this returns
     -- the actual List subtype.
   1 function List:clone()
***0     local ls = makelist({},self)
***0     ls:extend(self)
***0     return ls
     end

     --- Add an item to the end of the list.
     -- @param i An item
     -- @return the list
   1 function List:append(i)
***0     tinsert(self,i)
***0     return self
     end

   1 List.push = tinsert

     --- Extend the list by appending all the items in the given list.
     -- equivalent to 'a[len(a):] = L'.
     -- @tparam List L Another List
     -- @return the list
   1 function List:extend(L)
***0     assert_arg(1,L,'table')
***0     for i = 1,#L do tinsert(self,L[i]) end
***0     return self
     end

     --- Insert an item at a given position. i is the index of the
     -- element before which to insert.
     -- @int i index of element before whichh to insert
     -- @param x A data item
     -- @return the list
   1 function List:insert(i, x)
***0     assert_arg(1,i,'number')
***0     tinsert(self,i,x)
***0     return self
     end

     --- Insert an item at the beginning of the list.
     -- @param x a data item
     -- @return the list
   1 function List:put (x)
***0     return self:insert(1,x)
     end

     --- Remove an element given its index.
     -- (equivalent of Python's del s[i])
     -- @int i the index
     -- @return the list
   1 function List:remove (i)
***0     assert_arg(1,i,'number')
***0     tremove(self,i)
***0     return self
     end

     --- Remove the first item from the list whose value is given.
     -- (This is called 'remove' in Python; renamed to avoid confusion
     -- with table.remove)
     -- Return nil if there is no such item.
     -- @param x A data value
     -- @return the list
   1 function List:remove_value(x)
***0     for i=1,#self do
***0         if self[i]==x then tremove(self,i) return self end
         end
***0     return self
      end

     --- Remove the item at the given position in the list, and return it.
     -- If no index is specified, a:pop() returns the last item in the list.
     -- The item is also removed from the list.
     -- @int[opt] i An index
     -- @return the item
   1 function List:pop(i)
***0     if not i then i = #self end
***0     assert_arg(1,i,'number')
***0     return tremove(self,i)
     end

   1 List.get = List.pop

     --- Return the index in the list of the first item whose value is given.
     -- Return nil if there is no such item.
     -- @function List:index
     -- @param x A data value
     -- @int[opt=1] idx where to start search
     -- @return the index, or nil if not found.

   1 local tfind = tablex.find
   1 List.index = tfind

     --- Does this list contain the value?
     -- @param x A data value
     -- @return true or false
   1 function List:contains(x)
***0     return tfind(self,x) and true or false
     end

     --- Return the number of times value appears in the list.
     -- @param x A data value
     -- @return number of times x appears
   1 function List:count(x)
***0     local cnt=0
***0     for i=1,#self do
***0         if self[i]==x then cnt=cnt+1 end
         end
***0     return cnt
     end

     --- Sort the items of the list, in place.
     -- @func[opt='<'] cmp an optional comparison function
     -- @return the list
   1 function List:sort(cmp)
***0     if cmp then cmp = function_arg(1,cmp) end
***0     tsort(self,cmp)
***0     return self
     end

     --- Return a sorted copy of this list.
     -- @func[opt='<'] cmp an optional comparison function
     -- @return a new list
   1 function List:sorted(cmp)
***0     return List(self):sort(cmp)
     end

     --- Reverse the elements of the list, in place.
     -- @return the list
   1 function List:reverse()
***0     local t = self
***0     local n = #t
***0     for i = 1,n/2 do
***0         t[i],t[n] = t[n],t[i]
***0         n = n - 1
         end
***0     return self
     end

     --- Return the minimum and the maximum value of the list.
     -- @return minimum value
     -- @return maximum value
   1 function List:minmax()
***0     local vmin,vmax = 1e70,-1e70
***0     for i = 1,#self do
***0         local v = self[i]
***0         if v < vmin then vmin = v end
***0         if v > vmax then vmax = v end
         end
***0     return vmin,vmax
     end

     --- Emulate list slicing.  like  'list[first:last]' in Python.
     -- If first or last are negative then they are relative to the end of the list
     -- eg. slice(-2) gives last 2 entries in a list, and
     -- slice(-4,-2) gives from -4th to -2nd
     -- @param first An index
     -- @param last An index
     -- @return a new List
   1 function List:slice(first,last)
***0     return tsub(self,first,last)
     end

     --- Empty the list.
     -- @return the list
   1 function List:clear()
***0     for i=1,#self do tremove(self) end
***0     return self
     end

   1 local eps = 1.0e-10

     --- Emulate Python's range(x) function.
     -- Include it in List table for tidiness
     -- @int start A number
     -- @int[opt] finish A number greater than start; if absent,
     -- then start is 1 and finish is start
     -- @int[opt=1] incr an increment (may be less than 1)
     -- @return a List from start .. finish
     -- @usage List.range(0,3) == List{0,1,2,3}
     -- @usage List.range(4) = List{1,2,3,4}
     -- @usage List.range(5,1,-1) == List{5,4,3,2,1}
   1 function List.range(start,finish,incr)
***0     if not finish then
***0         finish = start
***0         start = 1
         end
***0     if incr then
***0     assert_arg(3,incr,'number')
***0     if math.ceil(incr) ~= incr then finish = finish + eps end
         else
***0         incr = 1
         end
***0     assert_arg(1,start,'number')
***0     assert_arg(2,finish,'number')
***0     local t = List()
***0     for i=start,finish,incr do tinsert(t,i) end
***0     return t
     end

     --- list:len() is the same as #list.
   1 function List:len()
***0     return #self
     end

     -- Extended operations --

     --- Remove a subrange of elements.
     -- equivalent to 'del s[i1:i2]' in Python.
     -- @int i1 start of range
     -- @int i2 end of range
     -- @return the list
   1 function List:chop(i1,i2)
***0     return tremovevalues(self,i1,i2)
     end

     --- Insert a sublist into a list
     -- equivalent to 's[idx:idx] = list' in Python
     -- @int idx index
     -- @tparam List list list to insert
     -- @return the list
     -- @usage  l = List{10,20}; l:splice(2,{21,22});  assert(l == List{10,21,22,20})
   1 function List:splice(idx,list)
***0     assert_arg(1,idx,'number')
***0     idx = idx - 1
***0     local i = 1
***0     for v in iter(list) do
***0         tinsert(self,i+idx,v)
***0         i = i + 1
         end
***0     return self
     end

     --- General slice assignment s[i1:i2] = seq.
     -- @int i1  start index
     -- @int i2  end index
     -- @tparam List seq a list
     -- @return the list
   1 function List:slice_assign(i1,i2,seq)
***0     assert_arg(1,i1,'number')
***0     assert_arg(1,i2,'number')
***0     i1,i2 = normalize_slice(self,i1,i2)
***0     if i2 >= i1 then self:chop(i1,i2) end
***0     self:splice(i1,seq)
***0     return self
     end

     --- Concatenation operator.
     -- @within metamethods
     -- @tparam List L another List
     -- @return a new list consisting of the list with the elements of the new list appended
   1 function List:__concat(L)
***0     assert_arg(1,L,'table')
***0     local ls = self:clone()
***0     ls:extend(L)
***0     return ls
     end

     --- Equality operator ==.  True iff all elements of two lists are equal.
     -- @within metamethods
     -- @tparam List L another List
     -- @return true or false
   1 function List:__eq(L)
***0     if #self ~= #L then return false end
***0     for i = 1,#self do
***0         if self[i] ~= L[i] then return false end
         end
***0     return true
     end

     --- Join the elements of a list using a delimiter.
     -- This method uses tostring on all elements.
     -- @string[opt=''] delim a delimiter string, can be empty.
     -- @return a string
   1 function List:join (delim)
***0     delim = delim or ''
***0     assert_arg(1,delim,'string')
***0     return concat(array_tostring(self),delim)
     end

     --- Join a list of strings. <br>
     -- Uses `table.concat` directly.
     -- @function List:concat
     -- @string[opt=''] delim a delimiter
     -- @return a string
   1 List.concat = concat

     local function tostring_q(val)
***0     local s = tostring(val)
***0     if type(val) == 'string' then
***0         s = '"'..s..'"'
         end
***0     return s
     end

     --- How our list should be rendered as a string. Uses join().
     -- @within metamethods
     -- @see List:join
   1 function List:__tostring()
***0     return '{'..self:join(',',tostring_q)..'}'
     end

     --- Call the function on each element of the list.
     -- @func fun a function or callable object
     -- @param ... optional values to pass to function
   1 function List:foreach (fun,...)
***0     fun = function_arg(1,fun)
***0     for i = 1,#self do
***0         fun(self[i],...)
         end
     end

     local function lookup_fun (obj,name)
***0     local f = obj[name]
***0     if not f then error(type(obj).." does not have method "..name,3) end
***0     return f
     end

     --- Call the named method on each element of the list.
     -- @string name the method name
     -- @param ... optional values to pass to function
   1 function List:foreachm (name,...)
***0     for i = 1,#self do
***0         local obj = self[i]
***0         local f = lookup_fun(obj,name)
***0         f(obj,...)
         end
     end

     --- Create a list of all elements which match a function.
     -- @func fun a boolean function
     -- @param[opt] arg optional argument to be passed as second argument of the predicate
     -- @return a new filtered list.
   1 function List:filter (fun,arg)
***0     return makelist(filter(self,fun,arg),self)
     end

     --- Split a string using a delimiter.
     -- @string s the string
     -- @string[opt] delim the delimiter (default spaces)
     -- @return a List of strings
     -- @see pl.utils.split
   1 function List.split (s,delim)
***0     assert_arg(1,s,'string')
***0     return makelist(split(s,delim))
     end

     --- Apply a function to all elements.
     -- Any extra arguments will be passed to the function.
     -- @func fun a function of at least one argument
     -- @param ... arbitrary extra arguments.
     -- @return a new list: {f(x) for x in self}
     -- @usage List{'one','two'}:map(string.upper) == {'ONE','TWO'}
     -- @see pl.tablex.imap
   1 function List:map (fun,...)
***0     return makelist(imap(fun,self,...),self)
     end

     --- Apply a function to all elements, in-place.
     -- Any extra arguments are passed to the function.
     -- @func fun A function that takes at least one argument
     -- @param ... arbitrary extra arguments.
     -- @return the list.
   1 function List:transform (fun,...)
***0     transform(fun,self,...)
***0     return self
     end

     --- Apply a function to elements of two lists.
     -- Any extra arguments will be passed to the function
     -- @func fun a function of at least two arguments
     -- @tparam List ls another list
     -- @param ... arbitrary extra arguments.
     -- @return a new list: {f(x,y) for x in self, for x in arg1}
     -- @see pl.tablex.imap2
   1 function List:map2 (fun,ls,...)
***0     return makelist(imap2(fun,self,ls,...),self)
     end

     --- apply a named method to all elements.
     -- Any extra arguments will be passed to the method.
     -- @string name name of method
     -- @param ... extra arguments
     -- @return a new list of the results
     -- @see pl.seq.mapmethod
   1 function List:mapm (name,...)
***0     local res = {}
***0     for i = 1,#self do
***0       local val = self[i]
***0       local fn = lookup_fun(val,name)
***0       res[i] = fn(val,...)
         end
***0     return makelist(res,self)
     end

     local function composite_call (method,f)
         return function(self,...)
***0         return self[method](self,f,...)
         end
     end

   1 function List.default_map_with(T)
         return function(self,name)
             local m
***0         if T then
***0             local f = lookup_fun(T,name)
***0             m = composite_call('map',f)
             else
***0             m = composite_call('mapn',name)
             end
***0         getmetatable(self)[name] = m -- and cache..
***0         return m
         end
     end

   1 List.default_map = List.default_map_with

     --- 'reduce' a list using a binary function.
     -- @func fun a function of two arguments
     -- @return result of the function
     -- @see pl.tablex.reduce
   1 function List:reduce (fun)
***0     return reduce(fun,self)
     end

     --- Partition a list using a classifier function.
     -- The function may return nil, but this will be converted to the string key '<nil>'.
     -- @func fun a function of at least one argument
     -- @param ... will also be passed to the function
     -- @treturn MultiMap a table where the keys are the returned values, and the values are Lists
     -- of values where the function returned that key.
     -- @see pl.MultiMap
   1 function List:partition (fun,...)
***0     fun = function_arg(1,fun)
***0     local res = {}
***0     for i = 1,#self do
***0         local val = self[i]
***0         local klass = fun(val,...)
***0         if klass == nil then klass = '<nil>' end
***0         if not res[klass] then res[klass] = List() end
***0         res[klass]:append(val)
         end
***0     return setmetatable(res,Multimap)
     end

     --- return an iterator over all values.
   1 function List:iter ()
***0     return iter(self)
     end

     --- Create an iterator over a sequence.
     -- This captures the Python concept of 'sequence'.
     -- For tables, iterates over all values with integer indices.
     -- @param seq a sequence; a string (over characters), a table, a file object (over lines) or an iterator function
     -- @usage for x in iterate {1,10,22,55} do io.write(x,',') end ==> 1,10,22,55
     -- @usage for ch in iterate 'help' do do io.write(ch,' ') end ==> h e l p
   1 function List.iterate(seq)
***0     if type(seq) == 'string' then
***0         local idx = 0
***0         local n = #seq
***0         local sub = string.sub
             return function ()
***0             idx = idx + 1
***0             if idx > n then return nil
                 else
***0                 return sub(seq,idx,idx)
                 end
             end
***0     elseif type(seq) == 'table' then
***0         local idx = 0
***0         local n = #seq
             return function()
***0             idx = idx + 1
***0             if idx > n then return nil
                 else
***0                 return seq[idx]
                 end
             end
***0     elseif type(seq) == 'function' then
***0         return seq
***0     elseif type(seq) == 'userdata' and io.type(seq) == 'file' then
***0         return seq:lines()
         end
     end
   1 iter = List.iterate

   1 return List


==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/pl/class.lua
==============================================================================
     --- Provides a reusable and convenient framework for creating classes in Lua.
     -- Two possible notations:
     --
     --    B = class(A)
     --    class.B(A)
     --
     -- The latter form creates a named class within the current environment. Note
     -- that this implicitly brings in `pl.utils` as a dependency.
     --
     -- See the Guide for further @{01-introduction.md.Simplifying_Object_Oriented_Programming_in_Lua|discussion}
     -- @module pl.class

     local error, getmetatable, io, pairs, rawget, rawset, setmetatable, tostring, type =
***0     _G.error, _G.getmetatable, _G.io, _G.pairs, _G.rawget, _G.rawset, _G.setmetatable, _G.tostring, _G.type
     local compat

     -- this trickery is necessary to prevent the inheritance of 'super' and
     -- the resulting recursive call problems.
     local function call_ctor (c,obj,...)
***0     local init = rawget(c,'_init')
***0     local parent_with_init = rawget(c,'_parent_with_init')

***0     if parent_with_init then
***0         if not init then -- inheriting an init
***0             init = rawget(parent_with_init, '_init')
***0             parent_with_init = rawget(parent_with_init, '_parent_with_init')
             end
***0         if parent_with_init then -- super() points to one above wherever _init came from
***0             rawset(obj,'super',function(obj,...)
***0                 call_ctor(parent_with_init,obj,...)
                 end)
             end
         else
             -- Without this, calling super() where none exists will sometimes loop and stack overflow
***0         rawset(obj,'super',nil)
         end

***0     local res = init(obj,...)
***0     if parent_with_init then -- If this execution of call_ctor set a super, unset it
***0         rawset(obj,'super',nil)
         end

***0     return res
     end

     --- initializes an __instance__ upon creation.
     -- @function class:_init
     -- @param ... parameters passed to the constructor
     -- @usage local Cat = class()
     -- function Cat:_init(name)
     --   --self:super(name)   -- call the ancestor initializer if needed
     --   self.name = name
     -- end
     --
     -- local pussycat = Cat("pussycat")
     -- print(pussycat.name)  --> pussycat

     --- checks whether an __instance__ is derived from some class.
     -- Works the other way around as `class_of`. It has two ways of using;
     -- 1) call with a class to check against, 2) call without params.
     -- @function instance:is_a
     -- @param some_class class to check against, or `nil` to return the class
     -- @return `true` if `instance` is derived from `some_class`, or if `some_class == nil` then
     -- it returns the class table of the instance
     -- @usage local pussycat = Lion()  -- assuming Lion derives from Cat
     -- if pussycat:is_a(Cat) then
     --   -- it's true, it is a Lion, but also a Cat
     -- end
     --
     -- if pussycat:is_a() == Lion then
     --   -- It's true
     -- end
     local function is_a(self,klass)
***0     if klass == nil then
             -- no class provided, so return the class this instance is derived from
***0         return getmetatable(self)
         end
***0     local m = getmetatable(self)
***0     if not m then return false end --*can't be an object!
***0     while m do
***0         if m == klass then return true end
***0         m = rawget(m,'_base')
         end
***0     return false
     end

     --- checks whether an __instance__ is derived from some class.
     -- Works the other way around as `is_a`.
     -- @function some_class:class_of
     -- @param some_instance instance to check against
     -- @return `true` if `some_instance` is derived from `some_class`
     -- @usage local pussycat = Lion()  -- assuming Lion derives from Cat
     -- if Cat:class_of(pussycat) then
     --   -- it's true
     -- end
     local function class_of(klass,obj)
***0     if type(klass) ~= 'table' or not rawget(klass,'is_a') then return false end
***0     return klass.is_a(obj,klass)
     end

     --- cast an object to another class.
     -- It is not clever (or safe!) so use carefully.
     -- @param some_instance the object to be changed
     -- @function some_class:cast
     local function cast (klass, obj)
***0     return setmetatable(obj,klass)
     end


     local function _class_tostring (obj)
***0     local mt = obj._class
***0     local name = rawget(mt,'_name')
***0     setmetatable(obj,nil)
***0     local str = tostring(obj)
***0     setmetatable(obj,mt)
***0     if name then str = name ..str:gsub('table','') end
***0     return str
     end

     local function tupdate(td,ts,dont_override)
***0     for k,v in pairs(ts) do
***0         if not dont_override or td[k] == nil then
***0             td[k] = v
             end
         end
     end

     local function _class(base,c_arg,c)
         -- the class `c` will be the metatable for all its objects,
         -- and they will look up their methods in it.
   1     local mt = {}   -- a metatable for the class to support __call and _handler
         -- can define class by passing it a plain table of methods
   1     local plain = type(base) == 'table' and not getmetatable(base)
   1     if plain then
***0         c = base
***0         base = c._base
         else
   1         c = c or {}
         end

   1     if type(base) == 'table' then
             -- our new class is a shallow copy of the base class!
             -- but be careful not to wipe out any methods we have been given at this point!
***0         tupdate(c,base,plain)
***0         c._base = base
             -- inherit the 'not found' handler, if present
***0         if rawget(c,'_handler') then mt.__index = c._handler end
   1     elseif base ~= nil then
***0         error("must derive from a table type",3)
         end

   1     c.__index = c
   1     setmetatable(c,mt)
   1     if not plain then
   1         if base and rawget(base,'_init') then c._parent_with_init = base end -- For super and inherited init
   1         c._init = nil
         end

   1     if base and rawget(base,'_class_init') then
***0         base._class_init(c,c_arg)
         end

         -- expose a ctor which can be called by <classname>(<args>)
         mt.__call = function(class_tbl,...)
             local obj
***0         if rawget(c,'_create') then obj = c._create(...) end
***0         if not obj then obj = {} end
***0         setmetatable(obj,c)

***0         if rawget(c,'_init') or rawget(c,'_parent_with_init') then -- constructor exists
***0             local res = call_ctor(c,obj,...)
***0             if res then -- _if_ a ctor returns a value, it becomes the object...
***0                 obj = res
***0                 setmetatable(obj,c)
                 end
             end

***0         if base and rawget(base,'_post_init') then
***0             base._post_init(obj)
             end

***0         return obj
         end
         -- Call Class.catch to set a handler for methods/properties not found in the class!
         c.catch = function(self, handler)
***0         if type(self) == "function" then
                 -- called using . instead of :
***0             handler = self
             end
***0         c._handler = handler
***0         mt.__index = handler
         end
   1     c.is_a = is_a
   1     c.class_of = class_of
   1     c.cast = cast
   1     c._class = c

   1     if not rawget(c,'__tostring') then
   1         c.__tostring = _class_tostring
         end

   1     return c
     end

     --- create a new class, derived from a given base class.
     -- Supporting two class creation syntaxes:
     -- either `Name = class(base)` or `class.Name(base)`.
     -- The first form returns the class directly and does not set its `_name`.
     -- The second form creates a variable `Name` in the current environment set
     -- to the class, and also sets `_name`.
     -- @function class
     -- @param base optional base class
     -- @param c_arg optional parameter to class constructor
     -- @param c optional table to be used as class
     local class
***0 class = setmetatable({},{
         __call = function(fun,...)
   1         return _class(...)
         end,
         __index = function(tbl,key)
***0         if key == 'class' then
***0             io.stderr:write('require("pl.class").class is deprecated. Use require("pl.class")\n')
***0             return class
             end
***0         compat = compat or require 'pl.compat'
***0         local env = compat.getfenv(2)
             return function(...)
***0             local c = _class(...)
***0             c._name = key
***0             rawset(env,key,c)
***0             return c
             end
         end
     })

***0 class.properties = class()

***0 function class.properties._class_init(klass)
         klass.__index = function(t,key)
             -- normal class lookup!
***0         local v = klass[key]
***0         if v then return v end
             -- is it a getter?
***0         v = rawget(klass,'get_'..key)
***0         if v then
***0             return v(t)
             end
             -- is it a field?
***0         return rawget(t,'_'..key)
         end
         klass.__newindex = function (t,key,value)
             -- if there's a setter, use that, otherwise directly set table
***0         local p = 'set_'..key
***0         local setter = klass[p]
***0         if setter then
***0             setter(t,value)
             else
***0             rawset(t,key,value)
             end
         end
     end


***0 return class


==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/pl/dir.lua
==============================================================================
     --- Listing files in directories and creating/removing directory paths.
     --
     -- Dependencies: `pl.utils`, `pl.path`
     --
     -- Soft Dependencies: `alien`, `ffi` (either are used on Windows for copying/moving files)
     -- @module pl.dir

   1 local utils = require 'pl.utils'
   1 local path = require 'pl.path'
   1 local is_windows = path.is_windows
   1 local ldir = path.dir
   1 local mkdir = path.mkdir
   1 local rmdir = path.rmdir
   1 local sub = string.sub
   1 local os,pcall,ipairs,pairs,require,setmetatable = os,pcall,ipairs,pairs,require,setmetatable
   1 local remove = os.remove
   1 local append = table.insert
   1 local assert_arg,assert_string,raise = utils.assert_arg,utils.assert_string,utils.raise

   1 local exists, isdir = path.exists, path.isdir
   1 local sep = path.sep

   1 local dir = {}

     local function makelist(l)
   1     return setmetatable(l, require('pl.List'))
     end

     local function assert_dir (n,val)
   1     assert_arg(n,val,'string',path.isdir,'not a directory',4)
     end

     local function filemask(mask)
   3     mask = utils.escape(path.normcase(mask))
   1     return '^'..mask:gsub('%%%*','.*'):gsub('%%%?','.')..'$'
     end

     --- Test whether a file name matches a shell pattern.
     -- Both parameters are case-normalized if operating system is
     -- case-insensitive.
     -- @string filename A file name.
     -- @string pattern A shell pattern. The only special characters are
     -- `'*'` and `'?'`: `'*'` matches any sequence of characters and
     -- `'?'` matches any single character.
     -- @treturn bool
     -- @raise dir and mask must be strings
   1 function dir.fnmatch(filename,pattern)
***0     assert_string(1,filename)
***0     assert_string(2,pattern)
***0     return path.normcase(filename):find(filemask(pattern)) ~= nil
     end

     --- Return a list of all file names within an array which match a pattern.
     -- @tab filenames An array containing file names.
     -- @string pattern A shell pattern (see `fnmatch`).
     -- @treturn List(string) List of matching file names.
     -- @raise dir and mask must be strings
   1 function dir.filter(filenames,pattern)
***0     assert_arg(1,filenames,'table')
***0     assert_string(2,pattern)
***0     local res = {}
***0     local mask = filemask(pattern)
***0     for i,f in ipairs(filenames) do
***0         if path.normcase(f):find(mask) then append(res,f) end
         end
***0     return makelist(res)
     end

     local function _listfiles(dirname,filemode,match)
***0     local res = {}
***0     local check = utils.choose(filemode,path.isfile,path.isdir)
***0     if not dirname then dirname = '.' end
***0     for f in ldir(dirname) do
***0         if f ~= '.' and f ~= '..' then
***0             local p = path.join(dirname,f)
***0             if check(p) and (not match or match(f)) then
***0                 append(res,p)
                 end
             end
         end
***0     return makelist(res)
     end

     --- return a list of all files in a directory which match a shell pattern.
     -- @string[opt='.'] dirname A directory.
     -- @string[opt] mask A shell pattern (see `fnmatch`). If not given, all files are returned.
     -- @treturn {string} list of files
     -- @raise dirname and mask must be strings
   1 function dir.getfiles(dirname,mask)
***0     dirname = dirname or '.'
***0     assert_dir(1,dirname)
***0     if mask then assert_string(2,mask) end
         local match
***0     if mask then
***0         mask = filemask(mask)
             match = function(f)
***0             return path.normcase(f):find(mask)
             end
         end
***0     return _listfiles(dirname,true,match)
     end

     --- return a list of all subdirectories of the directory.
     -- @string[opt='.'] dirname A directory.
     -- @treturn {string} a list of directories
     -- @raise dir must be a valid directory
   1 function dir.getdirectories(dirname)
***0     dirname = dirname or '.'
***0     assert_dir(1,dirname)
***0     return _listfiles(dirname,false)
     end

     local alien,ffi,ffi_checked,CopyFile,MoveFile,GetLastError,win32_errors,cmd_tmpfile

     local function execute_command(cmd,parms)
***0    if not cmd_tmpfile then cmd_tmpfile = path.tmpname () end
***0    local err = path.is_windows and ' > ' or ' 2> '
***0     cmd = cmd..' '..parms..err..utils.quote_arg(cmd_tmpfile)
***0     local ret = utils.execute(cmd)
***0     if not ret then
***0         local err = (utils.readfile(cmd_tmpfile):gsub('\n(.*)',''))
***0         remove(cmd_tmpfile)
***0         return false,err
         else
***0         remove(cmd_tmpfile)
***0         return true
         end
     end

     local function find_ffi_copyfile ()
***0     if not ffi_checked then
***0         ffi_checked = true
             local res
***0         res,alien = pcall(require,'alien')
***0         if not res then
***0             alien = nil
***0             res, ffi = pcall(require,'ffi')
             end
***0         if not res then
***0             ffi = nil
***0             return
             end
         else
***0         return
         end
***0     if alien then
             -- register the Win32 CopyFile and MoveFile functions
***0         local kernel = alien.load('kernel32.dll')
***0         CopyFile = kernel.CopyFileA
***0         CopyFile:types{'string','string','int',ret='int',abi='stdcall'}
***0         MoveFile = kernel.MoveFileA
***0         MoveFile:types{'string','string',ret='int',abi='stdcall'}
***0         GetLastError = kernel.GetLastError
***0         GetLastError:types{ret ='int', abi='stdcall'}
***0     elseif ffi then
***0         ffi.cdef [[
                 int CopyFileA(const char *src, const char *dest, int iovr);
                 int MoveFileA(const char *src, const char *dest);
                 int GetLastError();
***0         ]]
***0         CopyFile = ffi.C.CopyFileA
***0         MoveFile = ffi.C.MoveFileA
***0         GetLastError = ffi.C.GetLastError
         end
***0     win32_errors = {
             ERROR_FILE_NOT_FOUND    =         2,
             ERROR_PATH_NOT_FOUND    =         3,
             ERROR_ACCESS_DENIED    =          5,
             ERROR_WRITE_PROTECT    =          19,
             ERROR_BAD_UNIT         =          20,
             ERROR_NOT_READY        =          21,
             ERROR_WRITE_FAULT      =          29,
             ERROR_READ_FAULT       =          30,
             ERROR_SHARING_VIOLATION =         32,
             ERROR_LOCK_VIOLATION    =         33,
             ERROR_HANDLE_DISK_FULL  =         39,
             ERROR_BAD_NETPATH       =         53,
             ERROR_NETWORK_BUSY      =         54,
             ERROR_DEV_NOT_EXIST     =         55,
             ERROR_FILE_EXISTS       =         80,
             ERROR_OPEN_FAILED       =         110,
             ERROR_INVALID_NAME      =         123,
             ERROR_BAD_PATHNAME      =         161,
             ERROR_ALREADY_EXISTS    =         183,
         }
     end

     local function two_arguments (f1,f2)
***0     return utils.quote_arg(f1)..' '..utils.quote_arg(f2)
     end

     local function file_op (is_copy,src,dest,flag)
***0     if flag == 1 and path.exists(dest) then
***0         return false,"cannot overwrite destination"
         end
***0     if is_windows then
             -- if we haven't tried to load Alien/LuaJIT FFI before, then do so
***0         find_ffi_copyfile()
             -- fallback if there's no Alien, just use DOS commands *shudder*
             -- 'rename' involves a copy and then deleting the source.
***0         if not CopyFile then
***0             if path.is_windows then
***0                 src = src:gsub("/","\\")
***0                 dest = dest:gsub("/","\\")
                 end
***0             local res, err = execute_command('copy',two_arguments(src,dest))
***0             if not res then return false,err end
***0             if not is_copy then
***0                 return execute_command('del',utils.quote_arg(src))
                 end
***0             return true
             else
***0             if path.isdir(dest) then
***0                 dest = path.join(dest,path.basename(src))
                 end
                 local ret
***0             if is_copy then ret = CopyFile(src,dest,flag)
***0             else ret = MoveFile(src,dest) end
***0             if ret == 0 then
***0                 local err = GetLastError()
***0                 for name,value in pairs(win32_errors) do
***0                     if value == err then return false,name end
                     end
***0                 return false,"Error #"..err
***0             else return true
                 end
             end
         else -- for Unix, just use cp for now
***0         return execute_command(is_copy and 'cp' or 'mv',
***0             two_arguments(src,dest))
         end
     end

     --- copy a file.
     -- @string src source file
     -- @string dest destination file or directory
     -- @bool flag true if you want to force the copy (default)
     -- @treturn bool operation succeeded
     -- @raise src and dest must be strings
   1 function dir.copyfile (src,dest,flag)
***0     assert_string(1,src)
***0     assert_string(2,dest)
***0     flag = flag==nil or flag
***0     return file_op(true,src,dest,flag and 0 or 1)
     end

     --- move a file.
     -- @string src source file
     -- @string dest destination file or directory
     -- @treturn bool operation succeeded
     -- @raise src and dest must be strings
   1 function dir.movefile (src,dest)
***0     assert_string(1,src)
***0     assert_string(2,dest)
***0     return file_op(false,src,dest,0)
     end

     local function _dirfiles(dirname,attrib)
***0     local dirs = {}
***0     local files = {}
***0     for f in ldir(dirname) do
***0         if f ~= '.' and f ~= '..' then
***0             local p = path.join(dirname,f)
***0             local mode = attrib(p,'mode')
***0             if mode=='directory' then
***0                 append(dirs,f)
                 else
***0                 append(files,f)
                 end
             end
         end
***0     return makelist(dirs), makelist(files)
     end


     --- return an iterator which walks through a directory tree starting at root.
     -- The iterator returns (root,dirs,files)
     -- Note that dirs and files are lists of names (i.e. you must say path.join(root,d)
     -- to get the actual full path)
     -- If bottom_up is false (or not present), then the entries at the current level are returned
     -- before we go deeper. This means that you can modify the returned list of directories before
     -- continuing.
     -- This is a clone of os.walk from the Python libraries.
     -- @string root A starting directory
     -- @bool bottom_up False if we start listing entries immediately.
     -- @bool follow_links follow symbolic links
     -- @return an iterator returning root,dirs,files
     -- @raise root must be a directory
   1 function dir.walk(root,bottom_up,follow_links)
***0     assert_dir(1,root)
         local attrib
***0     if path.is_windows or not follow_links then
***0         attrib = path.attrib
         else
***0         attrib = path.link_attrib
         end

***0     local to_scan = { root }
***0     local to_return = {}
         local iter = function()
***0         while #to_scan > 0 do
***0             local current_root = table.remove(to_scan)
***0             local dirs,files = _dirfiles(current_root, attrib)
***0             for _, d in ipairs(dirs) do
***0                 table.insert(to_scan, current_root..path.sep..d)
                 end
***0             if not bottom_up then
***0                 return current_root, dirs, files
                 else
***0                 table.insert(to_return, { current_root, dirs, files })
                 end
             end
***0         if #to_return > 0 then
***0             return utils.unpack(table.remove(to_return))
             end
         end

***0     return iter
     end

     --- remove a whole directory tree.
     -- Symlinks in the tree will be deleted without following them.
     -- @string fullpath A directory path (must be an actual directory, not a symlink)
     -- @return true or nil
     -- @return error if failed
     -- @raise fullpath must be a string
   1 function dir.rmtree(fullpath)
***0     assert_dir(1,fullpath)
***0     if path.islink(fullpath) then return false,'will not follow symlink' end
***0     for root,dirs,files in dir.walk(fullpath,true) do
***0         if path.islink(root) then
                 -- sub dir is a link, remove link, do not follow
***0             if is_windows then
                     -- Windows requires using "rmdir". Deleting the link like a file
                     -- will instead delete all files from the target directory!!
***0                 local res, err = rmdir(root)
***0                 if not res then return nil,err .. ": " .. root end
                 else
***0                 local res, err = remove(root)
***0                 if not res then return nil,err .. ": " .. root end
                 end
             else
***0             for i,f in ipairs(files) do
***0                 local res, err = remove(path.join(root,f))
***0                 if not res then return nil,err .. ": " .. path.join(root,f) end
                 end
***0             local res, err = rmdir(root)
***0             if not res then return nil,err .. ": " .. root end
             end
         end
***0     return true
     end


     do
       local dirpat
   1   if path.is_windows then
***0       dirpat = '(.+)\\[^\\]+$'
       else
   1       dirpat = '(.+)/[^/]+$'
       end

       local _makepath
   1   function _makepath(p)
           -- windows root drive case
***0       if p:find '^%a:[\\]*$' then
***0           return true
           end
***0       if not path.isdir(p) then
***0           local subp = p:match(dirpat)
***0           if subp then
***0             local ok, err = _makepath(subp)
***0             if not ok then return nil, err end
               end
***0           return mkdir(p)
           else
***0           return true
           end
       end

       --- create a directory path.
       -- This will create subdirectories as necessary!
       -- @string p A directory path
       -- @return true on success, nil + errormsg on failure
       -- @raise failure to create
   1   function dir.makepath (p)
***0       assert_string(1,p)
***0       if path.is_windows then
***0           p = p:gsub("/", "\\")
           end
***0       return _makepath(path.abspath(p))
       end
     end

     --- clone a directory tree. Will always try to create a new directory structure
     -- if necessary.
     -- @string path1 the base path of the source tree
     -- @string path2 the new base path for the destination
     -- @func file_fun an optional function to apply on all files
     -- @bool verbose an optional boolean to control the verbosity of the output.
     --  It can also be a logging function that behaves like print()
     -- @return true, or nil
     -- @return error message, or list of failed directory creations
     -- @return list of failed file operations
     -- @raise path1 and path2 must be strings
     -- @usage clonetree('.','../backup',copyfile)
   1 function dir.clonetree (path1,path2,file_fun,verbose)
***0     assert_string(1,path1)
***0     assert_string(2,path2)
***0     if verbose == true then verbose = print end
***0     local abspath,normcase,isdir,join = path.abspath,path.normcase,path.isdir,path.join
***0     local faildirs,failfiles = {},{}
***0     if not isdir(path1) then return raise 'source is not a valid directory' end
***0     path1 = abspath(normcase(path1))
***0     path2 = abspath(normcase(path2))
***0     if verbose then verbose('normalized:',path1,path2) end
         -- particularly NB that the new path isn't fully contained in the old path
***0     if path1 == path2 then return raise "paths are the same" end
***0     local _,i2 = path2:find(path1,1,true)
***0     if i2 == #path1 and path2:sub(i2+1,i2+1) == path.sep then
***0         return raise 'destination is a subdirectory of the source'
         end
***0     local cp = path.common_prefix (path1,path2)
***0     local idx = #cp
***0     if idx == 0 then -- no common path, but watch out for Windows paths!
***0         if path1:sub(2,2) == ':' then idx = 3 end
         end
***0     for root,dirs,files in dir.walk(path1) do
***0         local opath = path2..root:sub(idx)
***0         if verbose then verbose('paths:',opath,root) end
***0         if not isdir(opath) then
***0             local ret = dir.makepath(opath)
***0             if not ret then append(faildirs,opath) end
***0             if verbose then verbose('creating:',opath,ret) end
             end
***0         if file_fun then
***0             for i,f in ipairs(files) do
***0                 local p1 = join(root,f)
***0                 local p2 = join(opath,f)
***0                 local ret = file_fun(p1,p2)
***0                 if not ret then append(failfiles,p2) end
***0                 if verbose then
***0                     verbose('files:',p1,p2,ret)
                     end
                 end
             end
         end
***0     return true,faildirs,failfiles
     end


     -- each entry of the stack is an array with three items:
     -- 1. the name of the directory
     -- 2. the lfs iterator function
     -- 3. the lfs iterator userdata
     local function treeiter(iterstack)
   5     local diriter = iterstack[#iterstack]
   5     if not diriter then
   1       return -- done
         end

   4     local dirname = diriter[1]
   4     local entry = diriter[2](diriter[3])
   4     if not entry then
   1       table.remove(iterstack)
   1       return treeiter(iterstack) -- tail-call to try next
         end

   3     if entry ~= "." and entry ~= ".." then
   1         entry = dirname .. sep .. entry
   2         if exists(entry) then  -- Just in case a symlink is broken.
   1             local is_dir = isdir(entry)
   1             if is_dir then
***0                 table.insert(iterstack, { entry, ldir(entry) })
                 end
   1             return entry, is_dir
             end
         end

   2     return treeiter(iterstack) -- tail-call to try next
     end


     --- return an iterator over all entries in a directory tree
     -- @string d a directory
     -- @return an iterator giving pathname and mode (true for dir, false otherwise)
     -- @raise d must be a non-empty string
   1 function dir.dirtree( d )
   1     assert( d and d ~= "", "directory parameter is missing or empty" )

   1     local last = sub ( d, -1 )
   1     if last == sep or last == '/' then
***0         d = sub( d, 1, -2 )
         end

   1     local iterstack = { {d, ldir(d)} }

   1     return treeiter, iterstack
     end


     --- Recursively returns all the file starting at 'path'. It can optionally take a shell pattern and
     -- only returns files that match 'shell_pattern'. If a pattern is given it will do a case insensitive search.
     -- @string[opt='.'] start_path  A directory.
     -- @string[opt='*'] shell_pattern A shell pattern (see `fnmatch`).
     -- @treturn List(string) containing all the files found recursively starting at 'path' and filtered by 'shell_pattern'.
     -- @raise start_path must be a directory
   1 function dir.getallfiles( start_path, shell_pattern )
   1     start_path = start_path or '.'
   1     assert_dir(1,start_path)
   1     shell_pattern = shell_pattern or "*"

   1     local files = {}
   1     local normcase = path.normcase
   5     for filename, mode in dir.dirtree( start_path ) do
   1         if not mode then
   1             local mask = filemask( shell_pattern )
   2             if normcase(filename):find( mask ) then
   1                 files[#files + 1] = filename
                 end
             end
         end

   1     return makelist(files)
     end

   1 return dir

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/pl/path.lua
==============================================================================
     --- Path manipulation and file queries.
     --
     -- This is modelled after Python's os.path library (10.1); see @{04-paths.md|the Guide}.
     --
     -- NOTE: the functions assume the paths being dealt with to originate
     -- from the OS the application is running on. Windows drive letters are not
     -- to be used when running on a Unix system for example. The one exception
     -- is Windows paths to allow both forward and backward slashes (since Lua
     -- also accepts those)
     --
     -- Dependencies: `pl.utils`, `lfs`
     -- @module pl.path

     -- imports and locals
***0 local _G = _G
***0 local sub = string.sub
***0 local getenv = os.getenv
***0 local tmpnam = os.tmpname
***0 local package = package
***0 local append, concat, remove = table.insert, table.concat, table.remove
***0 local utils = require 'pl.utils'
***0 local assert_string,raise = utils.assert_string,utils.raise

***0 local res,lfs = _G.pcall(_G.require,'lfs')
***0 if not res then
***0     error("pl.path requires LuaFileSystem")
     end

***0 local attrib = lfs.attributes
***0 local currentdir = lfs.currentdir
***0 local link_attrib = lfs.symlinkattributes

***0 local path = {}

     local function err_func(name, param, err, code)
***0   local ret = ("%s failed"):format(tostring(name))
***0   if param ~= nil then
***0     ret = ret .. (" for '%s'"):format(tostring(param))
       end
***0   ret = ret .. (": %s"):format(tostring(err))
***0   if code ~= nil then
***0     ret = ret .. (" (code %s)"):format(tostring(code))
       end
***0   return ret
     end

     --- Lua iterator over the entries of a given directory.
     -- Implicit link to [`luafilesystem.dir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
     -- @function dir
***0 path.dir = lfs.dir

     --- Creates a directory.
     -- Implicit link to [`luafilesystem.mkdir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
     -- @function mkdir
     path.mkdir = function(d)
***0   local ok, err, code = lfs.mkdir(d)
***0   if not ok then
***0     return ok, err_func("mkdir", d, err, code), code
       end
***0   return ok, err, code
     end

     --- Removes a directory.
     -- Implicit link to [`luafilesystem.rmdir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
     -- @function rmdir
     path.rmdir = function(d)
***0   local ok, err, code = lfs.rmdir(d)
***0   if not ok then
***0     return ok, err_func("rmdir", d, err, code), code
       end
***0   return ok, err, code
     end

     --- Gets attributes.
     -- Implicit link to [`luafilesystem.attributes`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
     -- @function attrib
     path.attrib = function(d, r)
***0   local ok, err, code = attrib(d, r)
***0   if not ok then
***0     return ok, err_func("attrib", d, err, code), code
       end
***0   return ok, err, code
     end

     --- Get the working directory.
     -- Implicit link to [`luafilesystem.currentdir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
     -- @function currentdir
     path.currentdir = function()
***0   local ok, err, code = currentdir()
***0   if not ok then
***0     return ok, err_func("currentdir", nil, err, code), code
       end
***0   return ok, err, code
     end

     --- Gets symlink attributes.
     -- Implicit link to [`luafilesystem.symlinkattributes`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
     -- @function link_attrib
     path.link_attrib = function(d, r)
***0   local ok, err, code = link_attrib(d, r)
***0   if not ok then
***0     return ok, err_func("link_attrib", d, err, code), code
       end
***0   return ok, err, code
     end

     --- Changes the working directory.
     -- On Windows, if a drive is specified, it also changes the current drive. If
     -- only specifying the drive, it will only switch drive, but not modify the path.
     -- Implicit link to [`luafilesystem.chdir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
     -- @function chdir
     path.chdir = function(d)
***0   local ok, err, code = lfs.chdir(d)
***0   if not ok then
***0     return ok, err_func("chdir", d, err, code), code
       end
***0   return ok, err, code
     end

     --- is this a directory?
     -- @string P A file path
***0 function path.isdir(P)
   3     assert_string(1,P)
   3     return attrib(P,'mode') == 'directory'
     end

     --- is this a file?
     -- @string P A file path
***0 function path.isfile(P)
   1     assert_string(1,P)
   1     return attrib(P,'mode') == 'file'
     end

     -- is this a symbolic link?
     -- @string P A file path
***0 function path.islink(P)
***0     assert_string(1,P)
***0     if link_attrib then
***0         return link_attrib(P,'mode')=='link'
         else
***0         return false
         end
     end

     --- return size of a file.
     -- @string P A file path
***0 function path.getsize(P)
***0     assert_string(1,P)
***0     return attrib(P,'size')
     end

     --- does a path exist?
     -- @string P A file path
     -- @return the file path if it exists (either as file, directory, socket, etc), nil otherwise
***0 function path.exists(P)
   1     assert_string(1,P)
   1     return attrib(P,'mode') ~= nil and P
     end

     --- Return the time of last access as the number of seconds since the epoch.
     -- @string P A file path
***0 function path.getatime(P)
***0     assert_string(1,P)
***0     return attrib(P,'access')
     end

     --- Return the time of last modification as the number of seconds since the epoch.
     -- @string P A file path
***0 function path.getmtime(P)
***0     assert_string(1,P)
***0     return attrib(P,'modification')
     end

     ---Return the system's ctime as the number of seconds since the epoch.
     -- @string P A file path
***0 function path.getctime(P)
***0     assert_string(1,P)
***0     return path.attrib(P,'change')
     end


     local function at(s,i)
  20     return sub(s,i,i)
     end

***0 path.is_windows = utils.is_windows

     local sep, other_sep, seps
     -- constant sep is the directory separator for this platform.
     -- constant dirsep is the separator in the PATH environment variable
***0 if path.is_windows then
***0     path.sep = '\\'; other_sep = '/'
***0     path.dirsep = ';'
***0     seps = { ['/'] = true, ['\\'] = true }
     else
***0     path.sep = '/'
***0     path.dirsep = ':'
***0     seps = { ['/'] = true }
     end
***0 sep = path.sep

     --- are we running Windows?
     -- @class field
     -- @name path.is_windows

     --- path separator for this platform.
     -- @class field
     -- @name path.sep

     --- separator for PATH for this platform
     -- @class field
     -- @name path.dirsep

     --- given a path, return the directory part and a file part.
     -- if there's no directory part, the first value will be empty
     -- @string P A file path
     -- @return directory part
     -- @return file part
     -- @usage
     -- local dir, file = path.splitpath("some/dir/myfile.txt")
     -- assert(dir == "some/dir")
     -- assert(file == "myfile.txt")
     --
     -- local dir, file = path.splitpath("some/dir/")
     -- assert(dir == "some/dir")
     -- assert(file == "")
     --
     -- local dir, file = path.splitpath("some_dir")
     -- assert(dir == "")
     -- assert(file == "some_dir")
***0 function path.splitpath(P)
   1     assert_string(1,P)
   1     local i = #P
   1     local ch = at(P,i)
  16     while i > 0 and ch ~= sep and ch ~= other_sep do
  15         i = i - 1
  30         ch = at(P,i)
         end
   1     if i == 0 then
***0         return '',P
         else
   3         return sub(P,1,i-1), sub(P,i+1)
         end
     end

     --- return an absolute path.
     -- @string P A file path
     -- @string[opt] pwd optional start path to use (default is current dir)
***0 function path.abspath(P,pwd)
***0     assert_string(1,P)
***0     if pwd then assert_string(2,pwd) end
***0     local use_pwd = pwd ~= nil
***0     if not use_pwd and not currentdir() then return P end
***0     P = P:gsub('[\\/]$','')
***0     pwd = pwd or currentdir()
***0     if not path.isabs(P) then
***0         P = path.join(pwd,P)
***0     elseif path.is_windows and not use_pwd and at(P,2) ~= ':' and at(P,2) ~= '\\' then
***0         P = pwd:sub(1,2)..P -- attach current drive to path like '\\fred.txt'
         end
***0     return path.normpath(P)
     end

     --- given a path, return the root part and the extension part.
     -- if there's no extension part, the second value will be empty
     -- @string P A file path
     -- @treturn string root part (everything upto the "."", maybe empty)
     -- @treturn string extension part (including the ".", maybe empty)
     -- @usage
     -- local file_path, ext = path.splitext("/bonzo/dog_stuff/cat.txt")
     -- assert(file_path == "/bonzo/dog_stuff/cat")
     -- assert(ext == ".txt")
     --
     -- local file_path, ext = path.splitext("")
     -- assert(file_path == "")
     -- assert(ext == "")
***0 function path.splitext(P)
   1     assert_string(1,P)
   1     local i = #P
   1     local ch = at(P,i)
   4     while i > 0 and ch ~= '.' do
   3         if seps[ch] then
***0             return P,''
             end
   3         i = i - 1
   6         ch = at(P,i)
         end
   1     if i == 0 then
***0         return P,''
         else
   3         return sub(P,1,i-1),sub(P,i)
         end
     end

     --- return the directory part of a path
     -- @string P A file path
     -- @treturn string everything before the last dir-separator
     -- @see splitpath
     -- @usage
     -- path.dirname("/some/path/file.txt")   -- "/some/path"
     -- path.dirname("file.txt")              -- "" (empty string)
***0 function path.dirname(P)
***0     assert_string(1,P)
***0     local p1 = path.splitpath(P)
***0     return p1
     end

     --- return the file part of a path
     -- @string P A file path
     -- @treturn string
     -- @see splitpath
     -- @usage
     -- path.basename("/some/path/file.txt")  -- "file.txt"
     -- path.basename("/some/path/file/")     -- "" (empty string)
***0 function path.basename(P)
   1     assert_string(1,P)
   1     local _,p2 = path.splitpath(P)
   1     return p2
     end

     --- get the extension part of a path.
     -- @string P A file path
     -- @treturn string
     -- @see splitext
     -- @usage
     -- path.extension("/some/path/file.txt") -- ".txt"
     -- path.extension("/some/path/file_txt") -- "" (empty string)
***0 function path.extension(P)
   1     assert_string(1,P)
   1     local _,p2 = path.splitext(P)
   1     return p2
     end

     --- is this an absolute path?
     -- @string P A file path
     -- @usage
     -- path.isabs("hello/path")    -- false
     -- path.isabs("/hello/path")   -- true
     -- -- Windows;
     -- path.isabs("hello\path")    -- false
     -- path.isabs("\hello\path")   -- true
     -- path.isabs("C:\hello\path") -- true
     -- path.isabs("C:hello\path")  -- false
***0 function path.isabs(P)
***0     assert_string(1,P)
***0     if path.is_windows and at(P,2) == ":" then
***0         return seps[at(P,3)] ~= nil
         end
***0     return seps[at(P,1)] ~= nil
     end

     --- return the path resulting from combining the individual paths.
     -- if the second (or later) path is absolute, we return the last absolute path (joined with any non-absolute paths following).
     -- empty elements (except the last) will be ignored.
     -- @string p1 A file path
     -- @string p2 A file path
     -- @string ... more file paths
     -- @treturn string the combined path
     -- @usage
     -- path.join("/first","second","third")   -- "/first/second/third"
     -- path.join("first","second/third")      -- "first/second/third"
     -- path.join("/first","/second","third")  -- "/second/third"
***0 function path.join(p1,p2,...)
***0     assert_string(1,p1)
***0     assert_string(2,p2)
***0     if select('#',...) > 0 then
***0         local p = path.join(p1,p2)
***0         local args = {...}
***0         for i = 1,#args do
***0             assert_string(i,args[i])
***0             p = path.join(p,args[i])
             end
***0         return p
         end
***0     if path.isabs(p2) then return p2 end
***0     local endc = at(p1,#p1)
***0     if endc ~= path.sep and endc ~= other_sep and endc ~= "" then
***0         p1 = p1..path.sep
         end
***0     return p1..p2
     end

     --- normalize the case of a pathname. On Unix, this returns the path unchanged,
     -- for Windows it converts;
     --
     -- * the path to lowercase
     -- * forward slashes to backward slashes
     -- @string P A file path
     -- @usage path.normcase("/Some/Path/File.txt")
     -- -- Windows: "\some\path\file.txt"
     -- -- Others : "/Some/Path/File.txt"
***0 function path.normcase(P)
   2     assert_string(1,P)
   2     if path.is_windows then
***0         return P:gsub('/','\\'):lower()
         else
   2         return P
         end
     end

     --- normalize a path name.
     -- `A//B`, `A/./B`, and `A/foo/../B` all become `A/B`.
     --
     -- An empty path results in '.'.
     -- @string P a file path
***0 function path.normpath(P)
***0     assert_string(1,P)
         -- Split path into anchor and relative path.
***0     local anchor = ''
***0     if path.is_windows then
***0         if P:match '^\\\\' then -- UNC
***0             anchor = '\\\\'
***0             P = P:sub(3)
***0         elseif seps[at(P, 1)] then
***0             anchor = '\\'
***0             P = P:sub(2)
***0         elseif at(P, 2) == ':' then
***0             anchor = P:sub(1, 2)
***0             P = P:sub(3)
***0             if seps[at(P, 1)] then
***0                 anchor = anchor..'\\'
***0                 P = P:sub(2)
                 end
             end
***0         P = P:gsub('/','\\')
         else
             -- According to POSIX, in path start '//' and '/' are distinct,
             -- but '///+' is equivalent to '/'.
***0         if P:match '^//' and at(P, 3) ~= '/' then
***0             anchor = '//'
***0             P = P:sub(3)
***0         elseif at(P, 1) == '/' then
***0             anchor = '/'
***0             P = P:match '^/*(.*)$'
             end
         end
***0     local parts = {}
***0     for part in P:gmatch('[^'..sep..']+') do
***0         if part == '..' then
***0             if #parts ~= 0 and parts[#parts] ~= '..' then
***0                 remove(parts)
                 else
***0                 append(parts, part)
                 end
***0         elseif part ~= '.' then
***0             append(parts, part)
             end
         end
***0     P = anchor..concat(parts, sep)
***0     if P == '' then P = '.' end
***0     return P
     end

     --- relative path from current directory or optional start point
     -- @string P a path
     -- @string[opt] start optional start point (default current directory)
***0 function path.relpath (P,start)
***0     assert_string(1,P)
***0     if start then assert_string(2,start) end
***0     local split,min,append = utils.split, math.min, table.insert
***0     P = path.abspath(P,start)
***0     start = start or currentdir()
         local compare
***0     if path.is_windows then
***0         P = P:gsub("/","\\")
***0         start = start:gsub("/","\\")
***0         compare = function(v) return v:lower() end
         else
***0         compare = function(v) return v end
         end
***0     local startl, Pl = split(start,sep), split(P,sep)
***0     local n = min(#startl,#Pl)
***0     if path.is_windows and n > 0 and at(Pl[1],2) == ':' and Pl[1] ~= startl[1] then
***0         return P
         end
***0     local k = n+1 -- default value if this loop doesn't bail out!
***0     for i = 1,n do
***0         if compare(startl[i]) ~= compare(Pl[i]) then
***0             k = i
                 break
             end
         end
***0     local rell = {}
***0     for i = 1, #startl-k+1 do rell[i] = '..' end
***0     if k <= #Pl then
***0         for i = k,#Pl do append(rell,Pl[i]) end
         end
***0     return table.concat(rell,sep)
     end


     --- Replace a starting '~' with the user's home directory.
     -- In windows, if HOME isn't set, then USERPROFILE is used in preference to
     -- HOMEDRIVE HOMEPATH. This is guaranteed to be writeable on all versions of Windows.
     -- @string P A file path
     -- @treturn[1] string The file path with the `~` prefix substituted, or the input path if it had no prefix.
     -- @treturn[2] nil
     -- @treturn[2] string Error message if the environment variables were unavailable.
***0 function path.expanduser(P)
***0     assert_string(1,P)
***0     if P:sub(1,1) ~= '~' then
***0         return P
         end

***0     local home = getenv('HOME')
***0     if (not home) and (not path.is_windows) then
             -- no more options to try on Nix
***0         return nil, "failed to expand '~' (HOME not set)"
         end

***0     if (not home) then
             -- try alternatives on Windows
***0         home = getenv 'USERPROFILE'
***0         if not home then
***0             local hd = getenv 'HOMEDRIVE'
***0             local hp = getenv 'HOMEPATH'
***0             if not (hd and hp) then
***0               return nil, "failed to expand '~' (HOME, USERPROFILE, and HOMEDRIVE and/or HOMEPATH not set)"
                 end
***0             home = hd..hp
             end
         end

***0     return home..sub(P,2)
     end


     ---Return a suitable full path to a new temporary file name.
     -- unlike os.tmpname(), it always gives you a writeable path (uses TEMP environment variable on Windows)
***0 function path.tmpname ()
***0     local res = tmpnam()
         -- On Windows if Lua is compiled using MSVC14 os.tmpname
         -- already returns an absolute path within TEMP env variable directory,
         -- no need to prepend it.
***0     if path.is_windows and not res:find(':') then
***0         res = getenv('TEMP')..res
         end
***0     return res
     end

     --- return the largest common prefix path of two paths.
     -- @string path1 a file path
     -- @string path2 a file path
     -- @return the common prefix (Windows: separators will be normalized, casing will be original)
***0 function path.common_prefix (path1,path2)
***0     assert_string(1,path1)
***0     assert_string(2,path2)
         -- get them in order!
***0     if #path1 > #path2 then path2,path1 = path1,path2 end
         local compare
***0     if path.is_windows then
***0         path1 = path1:gsub("/", "\\")
***0         path2 = path2:gsub("/", "\\")
***0         compare = function(v) return v:lower() end
         else
***0         compare = function(v) return v end
         end
***0     for i = 1,#path1 do
***0         if compare(at(path1,i)) ~= compare(at(path2,i)) then
***0             local cp = path1:sub(1,i-1)
***0             if at(path1,i-1) ~= sep then
***0                 cp = path.dirname(cp)
                 end
***0             return cp
             end
         end
***0     if at(path2,#path1+1) ~= sep then path1 = path.dirname(path1) end
***0     return path1
         --return ''
     end

     --- return the full path where a particular Lua module would be found.
     -- Both package.path and package.cpath is searched, so the result may
     -- either be a Lua file or a shared library.
     -- @string mod name of the module
     -- @return on success: path of module, lua or binary
     -- @return on error: nil, error string listing paths tried
***0 function path.package_path(mod)
***0     assert_string(1,mod)
         local res, err1, err2
***0     res, err1 = package.searchpath(mod,package.path)
***0     if res then return res,true end
***0     res, err2 = package.searchpath(mod,package.cpath)
***0     if res then return res,false end
***0     return raise ('cannot find module on path\n' .. err1 .. "\n" .. err2)
     end


     ---- finis -----
***0 return path

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/pl/tablex.lua
==============================================================================
     --- Extended operations on Lua tables.
     --
     -- See @{02-arrays.md.Useful_Operations_on_Tables|the Guide}
     --
     -- Dependencies: `pl.utils`, `pl.types`
     -- @module pl.tablex
***0 local utils = require ('pl.utils')
***0 local types = require ('pl.types')
***0 local getmetatable,setmetatable,require = getmetatable,setmetatable,require
***0 local tsort,append,remove = table.sort,table.insert,table.remove
***0 local min = math.min
***0 local pairs,type,unpack,select,tostring = pairs,type,utils.unpack,select,tostring
***0 local function_arg = utils.function_arg
***0 local assert_arg = utils.assert_arg

***0 local tablex = {}

     -- generally, functions that make copies of tables try to preserve the metatable.
     -- However, when the source has no obvious type, then we attach appropriate metatables
     -- like List, Map, etc to the result.
     local function setmeta (res,tbl,pl_class)
   2     local mt = getmetatable(tbl) or pl_class and require('pl.' .. pl_class)
   2     return mt and setmetatable(res, mt) or res
     end

     local function makelist(l)
***0     return setmetatable(l, require('pl.List'))
     end

     local function makemap(m)
***0     return setmetatable(m, require('pl.Map'))
     end

     local function complain (idx,msg)
***0     error(('argument %d is not %s'):format(idx,msg),3)
     end

     local function assert_arg_indexable (idx,val)
   4     if not types.is_indexable(val) then
***0         complain(idx,"indexable")
         end
     end

     local function assert_arg_iterable (idx,val)
   4     if not types.is_iterable(val) then
***0         complain(idx,"iterable")
         end
     end

     local function assert_arg_writeable (idx,val)
***0     if not types.is_writeable(val) then
***0         complain(idx,"writeable")
         end
     end

     --- copy a table into another, in-place.
     -- @within Copying
     -- @tab t1 destination table
     -- @tab t2 source (actually any iterable object)
     -- @return first table
***0 function tablex.update (t1,t2)
***0     assert_arg_writeable(1,t1)
***0     assert_arg_iterable(2,t2)
***0     for k,v in pairs(t2) do
***0         t1[k] = v
         end
***0     return t1
     end

     --- total number of elements in this table.
     -- Note that this is distinct from `#t`, which is the number
     -- of values in the array part; this value will always
     -- be greater or equal. The difference gives the size of
     -- the hash part, for practical purposes. Works for any
     -- object with a __pairs metamethod.
     -- @tab t a table
     -- @return the size
***0 function tablex.size (t)
***0     assert_arg_iterable(1,t)
***0     local i = 0
***0     for k in pairs(t) do i = i + 1 end
***0     return i
     end

     --- make a shallow copy of a table
     -- @within Copying
     -- @tab t an iterable source
     -- @return new table
***0 function tablex.copy (t)
   2     assert_arg_iterable(1,t)
   2     local res = {}
 114     for k,v in pairs(t) do
 112         res[k] = v
         end
   2     return res
     end

     local function cycle_aware_copy(t, cache)
***0     if type(t) ~= 'table' then return t end
***0     if cache[t] then return cache[t] end
***0     assert_arg_iterable(1,t)
***0     local res = {}
***0     cache[t] = res
***0     local mt = getmetatable(t)
***0     for k,v in pairs(t) do
***0         k = cycle_aware_copy(k, cache)
***0         v = cycle_aware_copy(v, cache)
***0         res[k] = v
         end
***0     setmetatable(res,mt)
***0     return res
     end

     --- make a deep copy of a table, recursively copying all the keys and fields.
     -- This supports cycles in tables; cycles will be reproduced in the copy.
     -- This will also set the copied table's metatable to that of the original.
     -- @within Copying
     -- @tab t A table
     -- @return new table
***0 function tablex.deepcopy(t)
***0     return cycle_aware_copy(t,{})
     end

***0 local abs = math.abs

     local function cycle_aware_compare(t1,t2,ignore_mt,eps,cache)
***0     if cache[t1] and cache[t1][t2] then return true end
***0     local ty1 = type(t1)
***0     local ty2 = type(t2)
***0     if ty1 ~= ty2 then return false end
         -- non-table types can be directly compared
***0     if ty1 ~= 'table' then
***0         if ty1 == 'number' and eps then return abs(t1-t2) < eps end
***0         return t1 == t2
         end
         -- as well as tables which have the metamethod __eq
***0     local mt = getmetatable(t1)
***0     if not ignore_mt and mt and mt.__eq then return t1 == t2 end
***0     for k1 in pairs(t1) do
***0         if t2[k1]==nil then return false end
         end
***0     for k2 in pairs(t2) do
***0         if t1[k2]==nil then return false end
         end
***0     cache[t1] = cache[t1] or {}
***0     cache[t1][t2] = true
***0     for k1,v1 in pairs(t1) do
***0         local v2 = t2[k1]
***0         if not cycle_aware_compare(v1,v2,ignore_mt,eps,cache) then return false end
         end
***0     return true
     end

     --- compare two values.
     -- if they are tables, then compare their keys and fields recursively.
     -- @within Comparing
     -- @param t1 A value
     -- @param t2 A value
     -- @bool[opt] ignore_mt if true, ignore __eq metamethod (default false)
     -- @number[opt] eps if defined, then used for any number comparisons
     -- @return true or false
***0 function tablex.deepcompare(t1,t2,ignore_mt,eps)
***0     return cycle_aware_compare(t1,t2,ignore_mt,eps,{})
     end

     --- compare two arrays using a predicate.
     -- @within Comparing
     -- @array t1 an array
     -- @array t2 an array
     -- @func cmp A comparison function; `bool = cmp(t1_value, t2_value)`
     -- @return true or false
     -- @usage
     -- assert(tablex.compare({ 1, 2, 3 }, { 1, 2, 3 }, "=="))
     --
     -- assert(tablex.compare(
     --    {1,2,3, hello = "world"},  -- fields are not compared!
     --    {1,2,3}, function(v1, v2) return v1 == v2 end)
***0 function tablex.compare (t1,t2,cmp)
***0     assert_arg_indexable(1,t1)
***0     assert_arg_indexable(2,t2)
***0     if #t1 ~= #t2 then return false end
***0     cmp = function_arg(3,cmp)
***0     for k = 1,#t1 do
***0         if not cmp(t1[k],t2[k]) then return false end
         end
***0     return true
     end

     --- compare two list-like tables using an optional predicate, without regard for element order.
     -- @within Comparing
     -- @array t1 a list-like table
     -- @array t2 a list-like table
     -- @param cmp A comparison function (may be nil)
***0 function tablex.compare_no_order (t1,t2,cmp)
***0     assert_arg_indexable(1,t1)
***0     assert_arg_indexable(2,t2)
***0     if cmp then cmp = function_arg(3,cmp) end
***0     if #t1 ~= #t2 then return false end
***0     local visited = {}
***0     for i = 1,#t1 do
***0         local val = t1[i]
             local gotcha
***0         for j = 1,#t2 do
***0             if not visited[j] then
                     local match
***0                 if cmp then match = cmp(val,t2[j]) else match = val == t2[j] end
***0                 if match then
***0                     gotcha = j
                         break
                     end
                 end
             end
***0         if not gotcha then return false end
***0         visited[gotcha] = true
         end
***0     return true
     end


     --- return the index of a value in a list.
     -- Like string.find, there is an optional index to start searching,
     -- which can be negative.
     -- @within Finding
     -- @array t A list-like table
     -- @param val A value
     -- @int idx index to start; -1 means last element,etc (default 1)
     -- @return index of value or nil if not found
     -- @usage find({10,20,30},20) == 2
     -- @usage find({'a','b','a','c'},'a',2) == 3
***0 function tablex.find(t,val,idx)
***0     assert_arg_indexable(1,t)
***0     idx = idx or 1
***0     if idx < 0 then idx = #t + idx + 1 end
***0     for i = idx,#t do
***0         if t[i] == val then return i end
         end
***0     return nil
     end

     --- return the index of a value in a list, searching from the end.
     -- Like string.find, there is an optional index to start searching,
     -- which can be negative.
     -- @within Finding
     -- @array t A list-like table
     -- @param val A value
     -- @param idx index to start; -1 means last element,etc (default `#t`)
     -- @return index of value or nil if not found
     -- @usage rfind({10,10,10},10) == 3
***0 function tablex.rfind(t,val,idx)
***0     assert_arg_indexable(1,t)
***0     idx = idx or #t
***0     if idx < 0 then idx = #t + idx + 1 end
***0     for i = idx,1,-1 do
***0         if t[i] == val then return i end
         end
***0     return nil
     end


     --- return the index (or key) of a value in a table using a comparison function.
     --
     -- *NOTE*: the 2nd return value of this function, the value returned
     -- by the comparison function, has a limitation that it cannot be `false`.
     -- Because if it is, then it indicates the comparison failed, and the
     -- function will continue the search. See examples.
     -- @within Finding
     -- @tab t A table
     -- @func cmp A comparison function
     -- @param arg an optional second argument to the function
     -- @return index of value, or nil if not found
     -- @return value returned by comparison function (cannot be `false`!)
     -- @usage
     -- -- using an operator
     -- local lst = { "Rudolph", true, false, 15 }
     -- local idx, cmp_result = tablex.rfind(lst, "==", "Rudolph")
     -- assert(idx == 1)
     -- assert(cmp_result == true)
     --
     -- local idx, cmp_result = tablex.rfind(lst, "==", false)
     -- assert(idx == 3)
     -- assert(cmp_result == true)       -- looking up 'false' works!
     --
     -- -- using a function returning the value looked up
     -- local cmp = function(v1, v2) return v1 == v2 and v2 end
     -- local idx, cmp_result = tablex.rfind(lst, cmp, "Rudolph")
     -- assert(idx == 1)
     -- assert(cmp_result == "Rudolph")  -- the value is returned
     --
     -- -- NOTE: this fails, since 'false' cannot be returned!
     -- local idx, cmp_result = tablex.rfind(lst, cmp, false)
     -- assert(idx == nil)               -- looking up 'false' failed!
     -- assert(cmp_result == nil)
***0 function tablex.find_if(t,cmp,arg)
***0     assert_arg_iterable(1,t)
***0     cmp = function_arg(2,cmp)
***0     for k,v in pairs(t) do
***0         local c = cmp(v,arg)
***0         if c then return k,c end
         end
***0     return nil
     end

     --- return a list of all values in a table indexed by another list.
     -- @tab tbl a table
     -- @array idx an index table (a list of keys)
     -- @return a list-like table
     -- @usage index_by({10,20,30,40},{2,4}) == {20,40}
     -- @usage index_by({one=1,two=2,three=3},{'one','three'}) == {1,3}
***0 function tablex.index_by(tbl,idx)
***0     assert_arg_indexable(1,tbl)
***0     assert_arg_indexable(2,idx)
***0     local res = {}
***0     for i = 1,#idx do
***0         res[i] = tbl[idx[i]]
         end
***0     return setmeta(res,tbl,'List')
     end

     --- apply a function to all values of a table.
     -- This returns a table of the results.
     -- Any extra arguments are passed to the function.
     -- @within MappingAndFiltering
     -- @func fun A function that takes at least one argument
     -- @tab t A table
     -- @param ... optional arguments
     -- @usage map(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900,fred=4}
***0 function tablex.map(fun,t,...)
***0     assert_arg_iterable(1,t)
***0     fun = function_arg(1,fun)
***0     local res = {}
***0     for k,v in pairs(t) do
***0         res[k] = fun(v,...)
         end
***0     return setmeta(res,t)
     end

     --- apply a function to all values of a list.
     -- This returns a table of the results.
     -- Any extra arguments are passed to the function.
     -- @within MappingAndFiltering
     -- @func fun A function that takes at least one argument
     -- @array t a table (applies to array part)
     -- @param ... optional arguments
     -- @return a list-like table
     -- @usage imap(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900}
***0 function tablex.imap(fun,t,...)
***0     assert_arg_indexable(1,t)
***0     fun = function_arg(1,fun)
***0     local res = {}
***0     for i = 1,#t do
***0         res[i] = fun(t[i],...) or false
         end
***0     return setmeta(res,t,'List')
     end

     --- apply a named method to values from a table.
     -- @within MappingAndFiltering
     -- @string name the method name
     -- @array t a list-like table
     -- @param ... any extra arguments to the method
     -- @return a `List` with the results of the method (1st result only)
     -- @usage
     -- local Car = {}
     -- Car.__index = Car
     -- function Car.new(car)
     --   return setmetatable(car or {}, Car)
     -- end
     -- Car.speed = 0
     -- function Car:faster(increase)
     --   self.speed = self.speed + increase
     --   return self.speed
     -- end
     --
     -- local ferrari = Car.new{ name = "Ferrari" }
     -- local lamborghini = Car.new{ name = "Lamborghini", speed = 50 }
     -- local cars = { ferrari, lamborghini }
     --
     -- assert(ferrari.speed == 0)
     -- assert(lamborghini.speed == 50)
     -- tablex.map_named_method("faster", cars, 10)
     -- assert(ferrari.speed == 10)
     -- assert(lamborghini.speed == 60)
***0 function tablex.map_named_method (name,t,...)
***0     utils.assert_string(1,name)
***0     assert_arg_indexable(2,t)
***0     local res = {}
***0     for i = 1,#t do
***0         local val = t[i]
***0         local fun = val[name]
***0         res[i] = fun(val,...)
         end
***0     return setmeta(res,t,'List')
     end

     --- apply a function to all values of a table, in-place.
     -- Any extra arguments are passed to the function.
     -- @func fun A function that takes at least one argument
     -- @tab t a table
     -- @param ... extra arguments passed to `fun`
     -- @see tablex.foreach
***0 function tablex.transform (fun,t,...)
***0     assert_arg_iterable(1,t)
***0     fun = function_arg(1,fun)
***0     for k,v in pairs(t) do
***0         t[k] = fun(v,...)
         end
     end

     --- generate a table of all numbers in a range.
     -- This is consistent with a numerical for loop.
     -- @int start  number
     -- @int finish number
     -- @int[opt=1] step  make this negative for start < finish
***0 function tablex.range (start,finish,step)
         local res
***0     step = step or 1
***0     if start == finish then
***0         res = {start}
***0     elseif (start > finish and step > 0) or (finish > start and step < 0) then
***0         res = {}
         else
***0         local k = 1
***0         res = {}
***0         for i=start,finish,step do res[k]=i; k=k+1 end
         end
***0     return makelist(res)
     end

     --- apply a function to values from two tables.
     -- @within MappingAndFiltering
     -- @func fun a function of at least two arguments
     -- @tab t1 a table
     -- @tab t2 a table
     -- @param ... extra arguments
     -- @return a table
     -- @usage map2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23,m=44}
***0 function tablex.map2 (fun,t1,t2,...)
***0     assert_arg_iterable(1,t1)
***0     assert_arg_iterable(2,t2)
***0     fun = function_arg(1,fun)
***0     local res = {}
***0     for k,v in pairs(t1) do
***0         res[k] = fun(v,t2[k],...)
         end
***0     return setmeta(res,t1,'List')
     end

     --- apply a function to values from two arrays.
     -- The result will be the length of the shortest array.
     -- @within MappingAndFiltering
     -- @func fun a function of at least two arguments
     -- @array t1 a list-like table
     -- @array t2 a list-like table
     -- @param ... extra arguments
     -- @usage imap2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23}
***0 function tablex.imap2 (fun,t1,t2,...)
***0     assert_arg_indexable(2,t1)
***0     assert_arg_indexable(3,t2)
***0     fun = function_arg(1,fun)
***0     local res,n = {},math.min(#t1,#t2)
***0     for i = 1,n do
***0         res[i] = fun(t1[i],t2[i],...)
         end
***0     return res
     end

     --- 'reduce' a list using a binary function.
     -- @func fun a function of two arguments
     -- @array t a list-like table
     -- @array memo optional initial memo value. Defaults to first value in table.
     -- @return the result of the function
     -- @usage reduce('+',{1,2,3,4}) == 10
***0 function tablex.reduce (fun,t,memo)
***0     assert_arg_indexable(2,t)
***0     fun = function_arg(1,fun)
***0     local n = #t
***0     if n == 0 then
***0         return memo
         end
***0     local res = memo and fun(memo, t[1]) or t[1]
***0     for i = 2,n do
***0         res = fun(res,t[i])
         end
***0     return res
     end

     --- apply a function to all elements of a table.
     -- The arguments to the function will be the value,
     -- the key and _finally_ any extra arguments passed to this function.
     -- Note that the Lua 5.0 function table.foreach passed the _key_ first.
     -- @within Iterating
     -- @tab t a table
     -- @func fun a function on the elements; `function(value, key, ...)`
     -- @param ... extra arguments passed to `fun`
     -- @see tablex.transform
***0 function tablex.foreach(t,fun,...)
***0     assert_arg_iterable(1,t)
***0     fun = function_arg(2,fun)
***0     for k,v in pairs(t) do
***0         fun(v,k,...)
         end
     end

     --- apply a function to all elements of a list-like table in order.
     -- The arguments to the function will be the value,
     -- the index and _finally_ any extra arguments passed to this function
     -- @within Iterating
     -- @array t a table
     -- @func fun a function with at least one argument
     -- @param ... optional arguments
***0 function tablex.foreachi(t,fun,...)
***0     assert_arg_indexable(1,t)
***0     fun = function_arg(2,fun)
***0     for i = 1,#t do
***0         fun(t[i],i,...)
         end
     end

     --- Apply a function to a number of tables.
     -- A more general version of map
     -- The result is a table containing the result of applying that function to the
     -- ith value of each table. Length of output list is the minimum length of all the lists
     -- @within MappingAndFiltering
     -- @func fun a function of n arguments
     -- @tab ... n tables
     -- @usage mapn(function(x,y,z) return x+y+z end, {1,2,3},{10,20,30},{100,200,300}) is {111,222,333}
     -- @usage mapn(math.max, {1,20,300},{10,2,3},{100,200,100}) is    {100,200,300}
     -- @param fun A function that takes as many arguments as there are tables
***0 function tablex.mapn(fun,...)
***0     fun = function_arg(1,fun)
***0     local res = {}
***0     local lists = {...}
***0     local minn = 1e40
***0     for i = 1,#lists do
***0         minn = min(minn,#(lists[i]))
         end
***0     for i = 1,minn do
***0         local args,k = {},1
***0         for j = 1,#lists do
***0             args[k] = lists[j][i]
***0             k = k + 1
             end
***0         res[#res+1] = fun(unpack(args))
         end
***0     return res
     end

     --- call the function with the key and value pairs from a table.
     -- The function can return a value and a key (note the order!). If both
     -- are not nil, then this pair is inserted into the result: if the key already exists, we convert the value for that
     -- key into a table and append into it. If only value is not nil, then it is appended to the result.
     -- @within MappingAndFiltering
     -- @func fun A function which will be passed each key and value as arguments, plus any extra arguments to pairmap.
     -- @tab t A table
     -- @param ... optional arguments
     -- @usage pairmap(function(k,v) return v end,{fred=10,bonzo=20}) is {10,20} _or_ {20,10}
     -- @usage pairmap(function(k,v) return {k,v},k end,{one=1,two=2}) is {one={'one',1},two={'two',2}}
***0 function tablex.pairmap(fun,t,...)
***0     assert_arg_iterable(1,t)
***0     fun = function_arg(1,fun)
***0     local res = {}
***0     for k,v in pairs(t) do
***0         local rv,rk = fun(k,v,...)
***0         if rk then
***0             if res[rk] then
***0                 if type(res[rk]) == 'table' then
***0                     table.insert(res[rk],rv)
                     else
***0                     res[rk] = {res[rk], rv}
                     end
                 else
***0                 res[rk] = rv
                 end
             else
***0             res[#res+1] = rv
             end
         end
***0     return res
     end

***0 local function keys_op(i,v) return i end

     --- return all the keys of a table in arbitrary order.
     -- @within Extraction
     -- @tab t A list-like table where the values are the keys of the input table
***0 function tablex.keys(t)
***0     assert_arg_iterable(1,t)
***0     return makelist(tablex.pairmap(keys_op,t))
     end

***0 local function values_op(i,v) return v end

     --- return all the values of the table in arbitrary order
     -- @within Extraction
     -- @tab t A list-like table where the values are the values of the input table
***0 function tablex.values(t)
***0     assert_arg_iterable(1,t)
***0     return makelist(tablex.pairmap(values_op,t))
     end

***0 local function index_map_op (i,v) return i,v end

     --- create an index map from a list-like table. The original values become keys,
     -- and the associated values are the indices into the original list.
     -- @array t a list-like table
     -- @return a map-like table
***0 function tablex.index_map (t)
***0     assert_arg_indexable(1,t)
***0     return makemap(tablex.pairmap(index_map_op,t))
     end

***0 local function set_op(i,v) return true,v end

     --- create a set from a list-like table. A set is a table where the original values
     -- become keys, and the associated values are all true.
     -- @array t a list-like table
     -- @return a set (a map-like table)
***0 function tablex.makeset (t)
***0     assert_arg_indexable(1,t)
***0     return setmetatable(tablex.pairmap(set_op,t),require('pl.Set'))
     end

     --- combine two tables, either as union or intersection. Corresponds to
     -- set operations for sets () but more general. Not particularly
     -- useful for list-like tables.
     -- @within Merging
     -- @tab t1 a table
     -- @tab t2 a table
     -- @bool dup true for a union, false for an intersection.
     -- @usage merge({alice=23,fred=34},{bob=25,fred=34}) is {fred=34}
     -- @usage merge({alice=23,fred=34},{bob=25,fred=34},true) is {bob=25,fred=34,alice=23}
     -- @see tablex.index_map
***0 function tablex.merge (t1,t2,dup)
***0     assert_arg_iterable(1,t1)
***0     assert_arg_iterable(2,t2)
***0     local res = {}
***0     for k,v in pairs(t1) do
***0         if dup or t2[k] then res[k] = v end
         end
***0     if dup then
***0       for k,v in pairs(t2) do
***0         res[k] = v
           end
         end
***0     return setmeta(res,t1,'Map')
     end

     --- the union of two map-like tables.
     -- If there are duplicate keys, the second table wins.
     -- @tab t1 a table
     -- @tab t2 a table
     -- @treturn tab
     -- @see tablex.merge
***0 function tablex.union(t1, t2)
***0     return tablex.merge(t1, t2, true)
     end

     --- the intersection of two map-like tables.
     -- @tab t1 a table
     -- @tab t2 a table
     -- @treturn tab
     -- @see tablex.merge
***0 function tablex.intersection(t1, t2)
***0     return tablex.merge(t1, t2, false)
     end

     --- a new table which is the difference of two tables.
     -- With sets (where the values are all true) this is set difference and
     -- symmetric difference depending on the third parameter.
     -- @within Merging
     -- @tab s1 a map-like table or set
     -- @tab s2 a map-like table or set
     -- @bool symm symmetric difference (default false)
     -- @return a map-like table or set
***0 function tablex.difference (s1,s2,symm)
***0     assert_arg_iterable(1,s1)
***0     assert_arg_iterable(2,s2)
***0     local res = {}
***0     for k,v in pairs(s1) do
***0         if s2[k] == nil then res[k] = v end
         end
***0     if symm then
***0         for k,v in pairs(s2) do
***0             if s1[k] == nil then res[k] = v end
             end
         end
***0     return setmeta(res,s1,'Map')
     end

     --- A table where the key/values are the values and value counts of the table.
     -- @array t a list-like table
     -- @func cmp a function that defines equality (otherwise uses ==)
     -- @return a map-like table
     -- @see seq.count_map
***0 function tablex.count_map (t,cmp)
***0     assert_arg_indexable(1,t)
***0     local res,mask = {},{}
***0     cmp = function_arg(2,cmp or '==')
***0     local n = #t
***0     for i = 1,#t do
***0         local v = t[i]
***0         if not mask[v] then
***0             mask[v] = true
                 -- check this value against all other values
***0             res[v] = 1  -- there's at least one instance
***0             for j = i+1,n do
***0                 local w = t[j]
***0                 local ok = cmp(v,w)
***0                 if ok then
***0                     res[v] = res[v] + 1
***0                     mask[w] = true
                     end
                 end
             end
         end
***0     return makemap(res)
     end

     --- filter an array's values using a predicate function
     -- @within MappingAndFiltering
     -- @array t a list-like table
     -- @func pred a boolean function
     -- @param arg optional argument to be passed as second argument of the predicate
***0 function tablex.filter (t,pred,arg)
   2     assert_arg_indexable(1,t)
   4     pred = function_arg(2,pred)
   2     local res,k = {},1
   4     for i = 1,#t do
   2         local v = t[i]
   4         if pred(v,arg) then
   2             res[k] = v
   2             k = k + 1
             end
         end
   2     return setmeta(res,t,'List')
     end

     --- return a table where each element is a table of the ith values of an arbitrary
     -- number of tables. It is equivalent to a matrix transpose.
     -- @within Merging
     -- @usage zip({10,20,30},{100,200,300}) is {{10,100},{20,200},{30,300}}
     -- @array ... arrays to be zipped
***0 function tablex.zip(...)
***0     return tablex.mapn(function(...) return {...} end,...)
     end

     local _copy
***0 function _copy (dest,src,idest,isrc,nsrc,clean_tail)
***0     idest = idest or 1
***0     isrc = isrc or 1
         local iend
***0     if not nsrc then
***0         nsrc = #src
***0         iend = #src
         else
***0         iend = isrc + min(nsrc-1,#src-isrc)
         end
***0     if dest == src then -- special case
***0         if idest > isrc and iend >= idest then -- overlapping ranges
***0             src = tablex.sub(src,isrc,nsrc)
***0             isrc = 1; iend = #src
             end
         end
***0     for i = isrc,iend do
***0         dest[idest] = src[i]
***0         idest = idest + 1
         end
***0     if clean_tail then
***0         tablex.clear(dest,idest)
         end
***0     return dest
     end

     --- copy an array into another one, clearing `dest` after `idest+nsrc`, if necessary.
     -- @within Copying
     -- @array dest a list-like table
     -- @array src a list-like table
     -- @int[opt=1] idest where to start copying values into destination
     -- @int[opt=1] isrc where to start copying values from source
     -- @int[opt=#src] nsrc number of elements to copy from source
***0 function tablex.icopy (dest,src,idest,isrc,nsrc)
***0     assert_arg_indexable(1,dest)
***0     assert_arg_indexable(2,src)
***0     return _copy(dest,src,idest,isrc,nsrc,true)
     end

     --- copy an array into another one.
     -- @within Copying
     -- @array dest a list-like table
     -- @array src a list-like table
     -- @int[opt=1] idest where to start copying values into destination
     -- @int[opt=1] isrc where to start copying values from source
     -- @int[opt=#src] nsrc number of elements to copy from source
***0 function tablex.move (dest,src,idest,isrc,nsrc)
***0     assert_arg_indexable(1,dest)
***0     assert_arg_indexable(2,src)
***0     return _copy(dest,src,idest,isrc,nsrc,false)
     end

***0 function tablex._normalize_slice(self,first,last)
***0   local sz = #self
***0   if not first then first=1 end
***0   if first<0 then first=sz+first+1 end
       -- make the range _inclusive_!
***0   if not last then last=sz end
***0   if last < 0 then last=sz+1+last end
***0   return first,last
     end

     --- Extract a range from a table, like  'string.sub'.
     -- If first or last are negative then they are relative to the end of the list
     -- eg. sub(t,-2) gives last 2 entries in a list, and
     -- sub(t,-4,-2) gives from -4th to -2nd
     -- @within Extraction
     -- @array t a list-like table
     -- @int first An index
     -- @int last An index
     -- @return a new List
***0 function tablex.sub(t,first,last)
***0     assert_arg_indexable(1,t)
***0     first,last = tablex._normalize_slice(t,first,last)
***0     local res={}
***0     for i=first,last do append(res,t[i]) end
***0     return setmeta(res,t,'List')
     end

     --- set an array range to a value. If it's a function we use the result
     -- of applying it to the indices.
     -- @array t a list-like table
     -- @param val a value
     -- @int[opt=1] i1 start range
     -- @int[opt=#t] i2 end range
***0 function tablex.set (t,val,i1,i2)
***0     assert_arg_indexable(1,t)
***0     i1,i2 = i1 or 1,i2 or #t
***0     if types.is_callable(val) then
***0         for i = i1,i2 do
***0             t[i] = val(i)
             end
         else
***0         for i = i1,i2 do
***0             t[i] = val
             end
         end
     end

     --- create a new array of specified size with initial value.
     -- @int n size
     -- @param val initial value (can be `nil`, but don't expect `#` to work!)
     -- @return the table
***0 function tablex.new (n,val)
***0     local res = {}
***0     tablex.set(res,val,1,n)
***0     return res
     end

     --- clear out the contents of a table.
     -- @array t a list
     -- @param istart optional start position
***0 function tablex.clear(t,istart)
***0     istart = istart or 1
***0     for i = istart,#t do remove(t) end
     end

     --- insert values into a table.
     -- similar to `table.insert` but inserts values from given table `values`,
     -- not the object itself, into table `t` at position `pos`.
     -- @within Copying
     -- @array t the list
     -- @int[opt] position (default is at end)
     -- @array values
***0 function tablex.insertvalues(t, ...)
   1     assert_arg(1,t,'table')
         local pos, values
   1     if select('#', ...) == 1 then
   1         pos,values = #t+1, ...
         else
***0         pos,values = ...
         end
   1     if #values > 0 then
   1         for i=#t,pos,-1 do
***0             t[i+#values] = t[i]
             end
   1         local offset = 1 - pos
   2         for i=pos,pos+#values-1 do
   1             t[i] = values[i + offset]
             end
         end
   1     return t
     end

     --- remove a range of values from a table.
     -- End of range may be negative.
     -- @array t a list-like table
     -- @int i1 start index
     -- @int i2 end index
     -- @return the table
***0 function tablex.removevalues (t,i1,i2)
***0     assert_arg(1,t,'table')
***0     i1,i2 = tablex._normalize_slice(t,i1,i2)
***0     for i = i1,i2 do
***0         remove(t,i1)
         end
***0     return t
     end

     local _find
     _find = function (t,value,tables)
***0     for k,v in pairs(t) do
***0         if v == value then return k end
         end
***0     for k,v in pairs(t) do
***0         if not tables[v] and type(v) == 'table' then
***0             tables[v] = true
***0             local res = _find(v,value,tables)
***0             if res then
***0                 res = tostring(res)
***0                 if type(k) ~= 'string' then
***0                     return '['..k..']'..res
                     else
***0                     return k..'.'..res
                     end
                 end
             end
         end
     end

     --- find a value in a table by recursive search.
     -- @within Finding
     -- @tab t the table
     -- @param value the value
     -- @array[opt] exclude any tables to avoid searching
     -- @return a fieldspec, e.g. 'a.b' or 'math.sin'
     -- @usage search(_G,math.sin,{package.path}) == 'math.sin'
***0 function tablex.search (t,value,exclude)
***0     assert_arg_iterable(1,t)
***0     local tables = {[t]=true}
***0     if exclude then
***0         for _,v in pairs(exclude) do tables[v] = true end
         end
***0     return _find(t,value,tables)
     end

     --- return an iterator to a table sorted by its keys
     -- @within Iterating
     -- @tab t the table
     -- @func f an optional comparison function (f(x,y) is true if x < y)
     -- @usage for k,v in tablex.sort(t) do print(k,v) end
     -- @return an iterator to traverse elements sorted by the keys
***0 function tablex.sort(t,f)
***0     local keys = {}
***0     for k in pairs(t) do keys[#keys + 1] = k end
***0     tsort(keys,f)
***0     local i = 0
         return function()
***0         i = i + 1
***0         return keys[i], t[keys[i]]
         end
     end

     --- return an iterator to a table sorted by its values
     -- @within Iterating
     -- @tab t the table
     -- @func f an optional comparison function (f(x,y) is true if x < y)
     -- @usage for k,v in tablex.sortv(t) do print(k,v) end
     -- @return an iterator to traverse elements sorted by the values
***0 function tablex.sortv(t,f)
***0     f = function_arg(2, f or '<')
***0     local keys = {}
***0     for k in pairs(t) do keys[#keys + 1] = k end
***0     tsort(keys,function(x, y) return f(t[x], t[y]) end)
***0     local i = 0
         return function()
***0         i = i + 1
***0         return keys[i], t[keys[i]]
         end
     end

     --- modifies a table to be read only.
     -- This only offers weak protection. Tables can still be modified with
     -- `table.insert` and `rawset`.
     --
     -- *NOTE*: for Lua 5.1 length, pairs and ipairs will not work, since the
     -- equivalent metamethods are only available in Lua 5.2 and newer.
     -- @tab t the table
     -- @return the table read only (a proxy).
***0 function tablex.readonly(t)
***0     local mt = {
             __index=t,
             __newindex=function(t, k, v) error("Attempt to modify read-only table", 2) end,
             __pairs=function() return pairs(t) end,
             __ipairs=function() return ipairs(t) end,
             __len=function() return #t end,
***0         __metatable=false
         }
***0     return setmetatable({}, mt)
     end

***0 return tablex

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/pl/types.lua
==============================================================================
     ---- Dealing with Detailed Type Information

     -- Dependencies `pl.utils`
     -- @module pl.types

***0 local utils = require 'pl.utils'
***0 local math_ceil = math.ceil
***0 local assert_arg = utils.assert_arg
***0 local types = {}

     --- is the object either a function or a callable object?.
     -- @param obj Object to check.
***0 function types.is_callable (obj)
***0     return type(obj) == 'function' or getmetatable(obj) and getmetatable(obj).__call and true
     end

     --- is the object of the specified type?.
     -- If the type is a string, then use type, otherwise compare with metatable.
     --
     -- NOTE: this function is imported from `utils.is_type`.
     -- @param obj An object to check
     -- @param tp The expected type
     -- @function is_type
     -- @see utils.is_type
***0 types.is_type = utils.is_type

***0 local fileMT = getmetatable(io.stdout)

     --- a string representation of a type.
     -- For tables and userdata with metatables, we assume that the metatable has a `_name`
     -- field. If the field is not present it will return 'unknown table' or
     -- 'unknown userdata'.
     -- Lua file objects return the type 'file'.
     -- @param obj an object
     -- @return a string like 'number', 'table', 'file' or 'List'
***0 function types.type (obj)
***0     local t = type(obj)
***0     if t == 'table' or t == 'userdata' then
***0         local mt = getmetatable(obj)
***0         if mt == fileMT then
***0             return 'file'
***0         elseif mt == nil then
***0             return t
             else
                 -- TODO: the "unknown" is weird, it should just return the type
***0             return mt._name or "unknown "..t
             end
         else
***0         return t
         end
     end

     --- is this number an integer?
     -- @param x a number
     -- @raise error if x is not a number
     -- @return boolean
***0 function types.is_integer (x)
***0     return math_ceil(x)==x
     end

     --- Check if the object is "empty".
     -- An object is considered empty if it is:
     --
     -- - `nil`
     -- - a table without any items (key-value pairs or indexes)
     -- - a string with no content ("")
     -- - not a nil/table/string
     -- @param o The object to check if it is empty.
     -- @param ignore_spaces If the object is a string and this is true the string is
     -- considered empty if it only contains spaces.
     -- @return `true` if the object is empty, otherwise a falsy value.
***0 function types.is_empty(o, ignore_spaces)
***0     if o == nil then
***0         return true
***0     elseif type(o) == "table" then
***0         return next(o) == nil
***0     elseif type(o) == "string" then
***0         return o == "" or (not not ignore_spaces and (not not o:find("^%s+$")))
         else
***0         return true
         end
     end

     local function check_meta (val)
   4     if type(val) == 'table' then return true end
***0     return getmetatable(val)
     end

     --- is an object 'array-like'?
     -- An object is array like if:
     --
     -- - it is a table, or
     -- - it has a metatable with `__len` and `__index` methods
     --
     -- NOTE: since `__len` is 5.2+, on 5.1 is usually returns `false` for userdata
     -- @param val any value.
     -- @return `true` if the object is array-like, otherwise a falsy value.
***0 function types.is_indexable (val)
   2     local mt = check_meta(val)
   2     if mt == true then return true end
***0     return mt and mt.__len and mt.__index and true
     end

     --- can an object be iterated over with `pairs`?
     -- An object is iterable if:
     --
     -- - it is a table, or
     -- - it has a metatable with a `__pairs` meta method
     --
     -- NOTE: since `__pairs` is 5.2+, on 5.1 is usually returns `false` for userdata
     -- @param val any value.
     -- @return `true` if the object is iterable, otherwise a falsy value.
***0 function types.is_iterable (val)
   2     local mt = check_meta(val)
   2     if mt == true then return true end
***0     return mt and mt.__pairs and true
     end

     --- can an object accept new key/pair values?
     -- An object is iterable if:
     --
     -- - it is a table, or
     -- - it has a metatable with a `__newindex` meta method
     --
     -- @param val any value.
     -- @return `true` if the object is writeable, otherwise a falsy value.
***0 function types.is_writeable (val)
***0     local mt = check_meta(val)
***0     if mt == true then return true end
***0     return mt and mt.__newindex and true
     end

     -- Strings that should evaluate to true.   -- TODO: add on/off ???
***0 local trues = { yes=true, y=true, ["true"]=true, t=true, ["1"]=true }
     -- Conditions types should evaluate to true.
***0 local true_types = {
         boolean=function(o, true_strs, check_objs) return o end,
         string=function(o, true_strs, check_objs)
***0         o = o:lower()
***0         if trues[o] then
***0             return true
             end
             -- Check alternative user provided strings.
***0         for _,v in ipairs(true_strs or {}) do
***0             if type(v) == "string" and o == v:lower() then
***0                 return true
                 end
             end
***0         return false
         end,
         number=function(o, true_strs, check_objs) return o ~= 0 end,
***0     table=function(o, true_strs, check_objs) if check_objs and next(o) ~= nil then return true end return false end
     }
     --- Convert to a boolean value.
     -- True values are:
     --
     -- * boolean: true.
     -- * string: 'yes', 'y', 'true', 't', '1' or additional strings specified by `true_strs`.
     -- * number: Any non-zero value.
     -- * table: Is not empty and `check_objs` is true.
     -- * everything else: Is not `nil` and `check_objs` is true.
     --
     -- @param o The object to evaluate.
     -- @param[opt] true_strs optional Additional strings that when matched should evaluate to true. Comparison is case insensitive.
     -- This should be a List of strings. E.g. "ja" to support German.
     -- @param[opt] check_objs True if objects should be evaluated.
     -- @return true if the input evaluates to true, otherwise false.
***0 function types.to_bool(o, true_strs, check_objs)
         local true_func
***0     if true_strs then
***0         assert_arg(2, true_strs, "table")
         end
***0     true_func = true_types[type(o)]
***0     if true_func then
***0         return true_func(o, true_strs, check_objs)
***0     elseif check_objs and o ~= nil then
***0         return true
         end
***0     return false
     end


***0 return types

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/pl/utils.lua
==============================================================================
     --- Generally useful routines.
     -- See  @{01-introduction.md.Generally_useful_functions|the Guide}.
     --
     -- Dependencies: `pl.compat`, all exported fields and functions from
     -- `pl.compat` are also available in this module.
     --
     -- @module pl.utils
***0 local format = string.format
***0 local compat = require 'pl.compat'
***0 local stdout = io.stdout
***0 local append = table.insert
***0 local concat = table.concat
***0 local _unpack = table.unpack  -- always injected by 'compat'
***0 local find = string.find
***0 local sub = string.sub
***0 local next = next
***0 local floor = math.floor

***0 local is_windows = compat.is_windows
***0 local err_mode = 'default'
     local raise
     local operators
***0 local _function_factories = {}


***0 local utils = { _VERSION = "1.14.0" }
***0 for k, v in pairs(compat) do utils[k] = v  end

     --- Some standard patterns
     -- @table patterns
***0 utils.patterns = {
         FLOAT = '[%+%-%d]%d*%.?%d*[eE]?[%+%-]?%d*', -- floating point number
         INTEGER = '[+%-%d]%d*',                     -- integer number
         IDEN = '[%a_][%w_]*',                       -- identifier
         FILE = '[%a%.\\][:%][%w%._%-\\]*',          -- file
     }


     --- Standard meta-tables as used by other Penlight modules
     -- @table stdmt
     -- @field List the List metatable
     -- @field Map the Map metatable
     -- @field Set the Set metatable
     -- @field MultiMap the MultiMap metatable
***0 utils.stdmt = {
         List = {_name='List'},
         Map = {_name='Map'},
         Set = {_name='Set'},
         MultiMap = {_name='MultiMap'},
     }


     --- pack an argument list into a table.
     -- @param ... any arguments
     -- @return a table with field `n` set to the length
     -- @function utils.pack
     -- @see compat.pack
     -- @see utils.npairs
     -- @see utils.unpack
***0 utils.pack = table.pack  -- added here to be symmetrical with unpack

     --- unpack a table and return its contents.
     --
     -- NOTE: this implementation differs from the Lua implementation in the way
     -- that this one DOES honor the `n` field in the table `t`, such that it is 'nil-safe'.
     -- @param t table to unpack
     -- @param[opt] i index from which to start unpacking, defaults to 1
     -- @param[opt] j index of the last element to unpack, defaults to `t.n` or else `#t`
     -- @return multiple return values from the table
     -- @function utils.unpack
     -- @see compat.unpack
     -- @see utils.pack
     -- @see utils.npairs
     -- @usage
     -- local t = table.pack(nil, nil, nil, 4)
     -- local a, b, c, d = table.unpack(t)   -- this `unpack` is NOT nil-safe, so d == nil
     --
     -- local a, b, c, d = utils.unpack(t)   -- this is nil-safe, so d == 4
***0 function utils.unpack(t, i, j)
***0     return _unpack(t, i or 1, j or t.n or #t)
     end

     --- print an arbitrary number of arguments using a format.
     -- Output will be sent to `stdout`.
     -- @param fmt The format (see `string.format`)
     -- @param ... Extra arguments for format
***0 function utils.printf(fmt, ...)
***0     utils.assert_string(1, fmt)
***0     utils.fprintf(stdout, fmt, ...)
     end

     --- write an arbitrary number of arguments to a file using a format.
     -- @param f File handle to write to.
     -- @param fmt The format (see `string.format`).
     -- @param ... Extra arguments for format
***0 function utils.fprintf(f,fmt,...)
***0     utils.assert_string(2,fmt)
***0     f:write(format(fmt,...))
     end

     do
         local function import_symbol(T,k,v,libname)
***0         local key = rawget(T,k)
             -- warn about collisions!
***0         if key and k ~= '_M' and k ~= '_NAME' and k ~= '_PACKAGE' and k ~= '_VERSION' then
***0             utils.fprintf(io.stderr,"warning: '%s.%s' will not override existing symbol\n",libname,k)
***0             return
             end
***0         rawset(T,k,v)
         end

         local function lookup_lib(T,t)
***0         for k,v in pairs(T) do
***0             if v == t then return k end
             end
***0         return '?'
         end

***0     local already_imported = {}

         --- take a table and 'inject' it into the local namespace.
         -- @param t The table (table), or module name (string), defaults to this `utils` module table
         -- @param T An optional destination table (defaults to callers environment)
***0     function utils.import(t,T)
***0         T = T or _G
***0         t = t or utils
***0         if type(t) == 'string' then
***0             t = require (t)
             end
***0         local libname = lookup_lib(T,t)
***0         if already_imported[t] then return end
***0         already_imported[t] = libname
***0         for k,v in pairs(t) do
***0             import_symbol(T,k,v,libname)
             end
         end
     end

     --- return either of two values, depending on a condition.
     -- @param cond A condition
     -- @param value1 Value returned if cond is truthy
     -- @param value2 Value returned if cond is falsy
***0 function utils.choose(cond, value1, value2)
***0     if cond then
***0         return value1
         else
***0         return value2
         end
     end

     --- convert an array of values to strings.
     -- @param t a list-like table
     -- @param[opt] temp (table) buffer to use, otherwise allocate
     -- @param[opt] tostr custom tostring function, called with (value,index). Defaults to `tostring`.
     -- @return the converted buffer
***0 function utils.array_tostring (t,temp,tostr)
***0     temp, tostr = temp or {}, tostr or tostring
***0     for i = 1,#t do
***0         temp[i] = tostr(t[i],i)
         end
***0     return temp
     end



     --- is the object of the specified type?
     -- If the type is a string, then use type, otherwise compare with metatable
     -- @param obj An object to check
     -- @param tp String of what type it should be
     -- @return boolean
     -- @usage utils.is_type("hello world", "string")   --> true
     -- -- or check metatable
     -- local my_mt = {}
     -- local my_obj = setmetatable(my_obj, my_mt)
     -- utils.is_type(my_obj, my_mt)  --> true
***0 function utils.is_type (obj,tp)
***0     if type(tp) == 'string' then return type(obj) == tp end
***0     local mt = getmetatable(obj)
***0     return tp == mt
     end



     --- an iterator with indices, similar to `ipairs`, but with a range.
     -- This is a nil-safe index based iterator that will return `nil` when there
     -- is a hole in a list. To be safe ensure that table `t.n` contains the length.
     -- @tparam table t the table to iterate over
     -- @tparam[opt=1] integer i_start start index
     -- @tparam[opt=t.n or #t] integer i_end end index
     -- @tparam[opt=1] integer step step size
     -- @treturn integer index
     -- @treturn any value at index (which can be `nil`!)
     -- @see utils.pack
     -- @see utils.unpack
     -- @usage
     -- local t = utils.pack(nil, 123, nil)  -- adds an `n` field when packing
     --
     -- for i, v in utils.npairs(t, 2) do  -- start at index 2
     --   t[i] = tostring(t[i])
     -- end
     --
     -- -- t = { n = 3, [2] = "123", [3] = "nil" }
***0 function utils.npairs(t, i_start, i_end, step)
***0   step = step or 1
***0   if step == 0 then
***0     error("iterator step-size cannot be 0", 2)
       end
***0   local i = (i_start or 1) - step
***0   i_end = i_end or t.n or #t
***0   if step < 0 then
         return function()
***0       i = i + step
***0       if i < i_end then
***0         return nil
           end
***0       return i, t[i]
         end

       else
         return function()
***0       i = i + step
***0       if i > i_end then
***0         return nil
           end
***0       return i, t[i]
         end
       end
     end



     --- an iterator over all non-integer keys (inverse of `ipairs`).
     -- It will skip any key that is an integer number, so negative indices or an
     -- array with holes will not return those either (so it returns slightly less than
     -- 'the inverse of `ipairs`').
     --
     -- This uses `pairs` under the hood, so any value that is iterable using `pairs`
     -- will work with this function.
     -- @tparam table t the table to iterate over
     -- @treturn key
     -- @treturn value
     -- @usage
     -- local t = {
     --   "hello",
     --   "world",
     --   hello = "hallo",
     --   world = "Welt",
     -- }
     --
     -- for k, v in utils.kpairs(t) do
     --   print("German: ", v)
     -- end
     --
     -- -- output;
     -- -- German: hallo
     -- -- German: Welt
***0 function utils.kpairs(t)
       local index
       return function()
         local value
         while true do
***0       index, value = next(t, index)
***0       if type(index) ~= "number" or floor(index) ~= index then
             break
           end
         end
***0     return index, value
       end
     end



     --- Error handling
     -- @section Error-handling

     --- assert that the given argument is in fact of the correct type.
     -- @param n argument index
     -- @param val the value
     -- @param tp the type
     -- @param verify an optional verification function
     -- @param msg an optional custom message
     -- @param lev optional stack position for trace, default 2
     -- @return the validated value
     -- @raise if `val` is not the correct type
     -- @usage
     -- local param1 = assert_arg(1,"hello",'table')  --> error: argument 1 expected a 'table', got a 'string'
     -- local param4 = assert_arg(4,'!@#$%^&*','string',path.isdir,'not a directory')
     --      --> error: argument 4: '!@#$%^&*' not a directory
***0 function utils.assert_arg (n,val,tp,verify,msg,lev)
  16     if type(val) ~= tp then
***0         error(("argument %d expected a '%s', got a '%s'"):format(n,tp,type(val)),lev or 2)
         end
  17     if verify and not verify(val) then
***0         error(("argument %d: '%s' %s"):format(n,val,msg),lev or 2)
         end
  16     return val
     end

     --- creates an Enum or constants lookup table for improved error handling.
     -- This helps prevent magic strings in code by throwing errors for accessing
     -- non-existing values, and/or converting strings/identifiers to other values.
     --
     -- Calling on the object does the same, but returns a soft error; `nil + err`, if
     -- the call is successful (the key exists), it will return the value.
     --
     -- When calling with varargs or an array the values will be equal to the keys.
     -- The enum object is read-only.
     -- @tparam table|vararg ... the input for the Enum. If varargs or an array then the
     -- values in the Enum will be equal to the names (must be strings), if a hash-table
     -- then values remain (any type), and the keys must be strings.
     -- @return Enum object (read-only table/object)
     -- @usage -- Enum access at runtime
     -- local obj = {}
     -- obj.MOVEMENT = utils.enum("FORWARD", "REVERSE", "LEFT", "RIGHT")
     --
     -- if current_movement == obj.MOVEMENT.FORWARD then
     --   -- do something
     --
     -- elseif current_movement == obj.MOVEMENT.REVERES then
     --   -- throws error due to typo 'REVERES', so a silent mistake becomes a hard error
     --   -- "'REVERES' is not a valid value (expected one of: 'FORWARD', 'REVERSE', 'LEFT', 'RIGHT')"
     --
     -- end
     -- @usage -- standardized error codes
     -- local obj = {
     --   ERR = utils.enum {
     --     NOT_FOUND = "the item was not found",
     --     OUT_OF_BOUNDS = "the index is outside the allowed range"
     --   },
     --
     --   some_method = function(self)
     --     return nil, self.ERR.OUT_OF_BOUNDS
     --   end,
     -- }
     --
     -- local result, err = obj:some_method()
     -- if not result then
     --   if err == obj.ERR.NOT_FOUND then
     --     -- check on error code, not magic strings
     --
     --   else
     --     -- return the error description, contained in the constant
     --     return nil, "error: "..err  -- "error: the index is outside the allowed range"
     --   end
     -- end
     -- @usage -- validating/converting user-input
     -- local color = "purple"
     -- local ansi_colors = utils.enum {
     --   black     = 30,
     --   red       = 31,
     --   green     = 32,
     -- }
     -- local color_code, err = ansi_colors(color) -- calling on the object, returns the value from the enum
     -- if not color_code then
     --   print("bad 'color', " .. err)
     --   -- "bad 'color', 'purple' is not a valid value (expected one of: 'black', 'red', 'green')"
     --   os.exit(1)
     -- end
***0 function utils.enum(...)
***0   local first = select(1, ...)
***0   local enum = {}
       local lst

***0   if type(first) ~= "table" then
         -- vararg with strings
***0     lst = utils.pack(...)
***0     for i, value in utils.npairs(lst) do
***0       utils.assert_arg(i, value, "string")
***0       enum[value] = value
         end

       else
         -- table/array with values
***0     utils.assert_arg(1, first, "table")
***0     lst = {}
         -- first add array part
***0     for i, value in ipairs(first) do
***0       if type(value) ~= "string" then
***0         error(("expected 'string' but got '%s' at index %d"):format(type(value), i), 2)
           end
***0       lst[i] = value
***0       enum[value] = value
         end
         -- add key-ed part
***0     for key, value in utils.kpairs(first) do
***0       if type(key) ~= "string" then
***0         error(("expected key to be 'string' but got '%s'"):format(type(key)), 2)
           end
***0       if enum[key] then
***0         error(("duplicate entry in array and hash part: '%s'"):format(key), 2)
           end
***0       enum[key] = value
***0       lst[#lst+1] = key
         end
       end

***0   if not lst[1] then
***0     error("expected at least 1 entry", 2)
       end

***0   local valid = "(expected one of: '" .. concat(lst, "', '") .. "')"
***0   setmetatable(enum, {
         __index = function(self, key)
***0       error(("'%s' is not a valid value %s"):format(tostring(key), valid), 2)
         end,
         __newindex = function(self, key, value)
***0       error("the Enum object is read-only", 2)
         end,
         __call = function(self, key)
***0       if type(key) == "string" then
***0         local v = rawget(self, key)
***0         if v ~= nil then
***0           return v
             end
           end
***0       return nil, ("'%s' is not a valid value %s"):format(tostring(key), valid)
         end
       })

***0   return enum
     end


     --- process a function argument.
     -- This is used throughout Penlight and defines what is meant by a function:
     -- Something that is callable, or an operator string as defined by <code>pl.operator</code>,
     -- such as '>' or '#'. If a function factory has been registered for the type, it will
     -- be called to get the function.
     -- @param idx argument index
     -- @param f a function, operator string, or callable object
     -- @param msg optional error message
     -- @return a callable
     -- @raise if idx is not a number or if f is not callable
***0 function utils.function_arg (idx,f,msg)
   2     utils.assert_arg(1,idx,'number')
   2     local tp = type(f)
   2     if tp == 'function' then return f end  -- no worries!
         -- ok, a string can correspond to an operator (like '==')
***0     if tp == 'string' then
***0         if not operators then operators = require 'pl.operator'.optable end
***0         local fn = operators[f]
***0         if fn then return fn end
***0         local fn, err = utils.string_lambda(f)
***0         if not fn then error(err..': '..f) end
***0         return fn
***0     elseif tp == 'table' or tp == 'userdata' then
***0         local mt = getmetatable(f)
***0         if not mt then error('not a callable object',2) end
***0         local ff = _function_factories[mt]
***0         if not ff then
***0             if not mt.__call then error('not a callable object',2) end
***0             return f
             else
***0             return ff(f) -- we have a function factory for this type!
             end
         end
***0     if not msg then msg = " must be callable" end
***0     if idx > 0 then
***0         error("argument "..idx..": "..msg,2)
         else
***0         error(msg,2)
         end
     end


     --- assert the common case that the argument is a string.
     -- @param n argument index
     -- @param val a value that must be a string
     -- @return the validated value
     -- @raise val must be a string
     -- @usage
     -- local val = 42
     -- local param2 = utils.assert_string(2, val) --> error: argument 2 expected a 'string', got a 'number'
***0 function utils.assert_string (n, val)
  12     return utils.assert_arg(n,val,'string',nil,nil,3)
     end

     --- control the error strategy used by Penlight.
     -- This is a global setting that controls how `utils.raise` behaves:
     --
     -- - 'default': return `nil + error` (this is the default)
     -- - 'error': throw a Lua error
     -- - 'quit': exit the program
     --
     -- @param mode either 'default', 'quit'  or 'error'
     -- @see utils.raise
***0 function utils.on_error (mode)
***0     mode = tostring(mode)
***0     if ({['default'] = 1, ['quit'] = 2, ['error'] = 3})[mode] then
***0       err_mode = mode
         else
           -- fail loudly
***0       local err = "Bad argument expected string; 'default', 'quit', or 'error'. Got '"..tostring(mode).."'"
***0       if err_mode == 'default' then
***0         error(err, 2)  -- even in 'default' mode fail loud in this case
           end
***0       raise(err)
         end
     end

     --- used by Penlight functions to return errors. Its global behaviour is controlled
     -- by `utils.on_error`.
     -- To use this function you MUST use it in conjunction with `return`, since it might
     -- return `nil + error`.
     -- @param err the error string.
     -- @see utils.on_error
     -- @usage
     -- if some_condition then
     --   return utils.raise("some condition was not met")  -- MUST use 'return'!
     -- end
***0 function utils.raise (err)
***0     if err_mode == 'default' then
***0         return nil, err
***0     elseif err_mode == 'quit' then
***0         return utils.quit(err)
         else
***0         error(err, 2)
         end
     end
***0 raise = utils.raise



     --- File handling
     -- @section files

     --- return the contents of a file as a string
     -- @param filename The file path
     -- @param is_bin open in binary mode
     -- @return file contents
***0 function utils.readfile(filename,is_bin)
***0     local mode = is_bin and 'b' or ''
***0     utils.assert_string(1,filename)
***0     local f,open_err = io.open(filename,'r'..mode)
***0     if not f then return raise (open_err) end
***0     local res,read_err = f:read('*a')
***0     f:close()
***0     if not res then
             -- Errors in io.open have "filename: " prefix,
             -- error in file:read don't, add it.
***0         return raise (filename..": "..read_err)
         end
***0     return res
     end

     --- write a string to a file
     -- @param filename The file path
     -- @param str The string
     -- @param is_bin open in binary mode
     -- @return true or nil
     -- @return error message
     -- @raise error if filename or str aren't strings
***0 function utils.writefile(filename,str,is_bin)
***0     local mode = is_bin and 'b' or ''
***0     utils.assert_string(1,filename)
***0     utils.assert_string(2,str)
***0     local f,err = io.open(filename,'w'..mode)
***0     if not f then return raise(err) end
***0     local ok, write_err = f:write(str)
***0     f:close()
***0     if not ok then
             -- Errors in io.open have "filename: " prefix,
             -- error in file:write don't, add it.
***0         return raise (filename..": "..write_err)
         end
***0     return true
     end

     --- return the contents of a file as a list of lines
     -- @param filename The file path
     -- @return file contents as a table
     -- @raise error if filename is not a string
***0 function utils.readlines(filename)
***0     utils.assert_string(1,filename)
***0     local f,err = io.open(filename,'r')
***0     if not f then return raise(err) end
***0     local res = {}
***0     for line in f:lines() do
***0         append(res,line)
         end
***0     f:close()
***0     return res
     end

     --- OS functions
     -- @section OS-functions

     --- execute a shell command and return the output.
     -- This function redirects the output to tempfiles and returns the content of those files.
     -- @param cmd a shell command
     -- @param bin boolean, if true, read output as binary file
     -- @return true if successful
     -- @return actual return code
     -- @return stdout output (string)
     -- @return errout output (string)
***0 function utils.executeex(cmd, bin)
***0     local outfile = os.tmpname()
***0     local errfile = os.tmpname()

***0     if is_windows and not outfile:find(':') then
***0         outfile = os.getenv('TEMP')..outfile
***0         errfile = os.getenv('TEMP')..errfile
         end
***0     cmd = cmd .. " > " .. utils.quote_arg(outfile) .. " 2> " .. utils.quote_arg(errfile)

***0     local success, retcode = utils.execute(cmd)
***0     local outcontent = utils.readfile(outfile, bin)
***0     local errcontent = utils.readfile(errfile, bin)
***0     os.remove(outfile)
***0     os.remove(errfile)
***0     return success, retcode, (outcontent or ""), (errcontent or "")
     end

     --- Quote and escape an argument of a command.
     -- Quotes a single (or list of) argument(s) of a command to be passed
     -- to `os.execute`, `pl.utils.execute` or `pl.utils.executeex`.
     -- @param argument (string or table/list) the argument to quote. If a list then
     -- all arguments in the list will be returned as a single string quoted.
     -- @return quoted and escaped argument.
     -- @usage
     -- local options = utils.quote_arg {
     --     "-lluacov",
     --     "-e",
     --     "utils = print(require('pl.utils')._VERSION",
     -- }
     -- -- returns: -lluacov -e 'utils = print(require('\''pl.utils'\'')._VERSION'
***0 function utils.quote_arg(argument)
***0     if type(argument) == "table" then
             -- encode an entire table
***0         local r = {}
***0         for i, arg in ipairs(argument) do
***0             r[i] = utils.quote_arg(arg)
             end

***0         return concat(r, " ")
         end
         -- only a single argument
***0     if is_windows then
***0         if argument == "" or argument:find('[ \f\t\v]') then
                 -- Need to quote the argument.
                 -- Quotes need to be escaped with backslashes;
                 -- additionally, backslashes before a quote, escaped or not,
                 -- need to be doubled.
                 -- See documentation for CommandLineToArgvW Windows function.
***0             argument = '"' .. argument:gsub([[(\*)"]], [[%1%1\"]]):gsub([[\+$]], "%0%0") .. '"'
             end

             -- os.execute() uses system() C function, which on Windows passes command
             -- to cmd.exe. Escape its special characters.
***0         return (argument:gsub('["^<>!|&%%]', "^%0"))
         else
***0         if argument == "" or argument:find('[^a-zA-Z0-9_@%+=:,./-]') then
                 -- To quote arguments on posix-like systems use single quotes.
                 -- To represent an embedded single quote close quoted string ('),
                 -- add escaped quote (\'), open quoted string again (').
***0             argument = "'" .. argument:gsub("'", [['\'']]) .. "'"
             end

***0         return argument
         end
     end

     --- error out of this program gracefully.
     -- @param[opt] code The exit code, defaults to -`1` if omitted
     -- @param msg The exit message will be sent to `stderr` (will be formatted with the extra parameters)
     -- @param ... extra arguments for message's format'
     -- @see utils.fprintf
     -- @usage utils.quit(-1, "Error '%s' happened", "42")
     -- -- is equivalent to
     -- utils.quit("Error '%s' happened", "42")  --> Error '42' happened
***0 function utils.quit(code, msg, ...)
***0     if type(code) == 'string' then
***0         utils.fprintf(io.stderr, code, msg, ...)
***0         io.stderr:write('\n')
***0         code = -1 -- TODO: this is odd, see the test. Which returns 255 as exit code
***0     elseif msg then
***0         utils.fprintf(io.stderr, msg, ...)
***0         io.stderr:write('\n')
         end
***0     os.exit(code, true)
     end


     --- String functions
     -- @section string-functions

     --- escape any Lua 'magic' characters in a string
     -- @param s The input string
***0 function utils.escape(s)
   1     utils.assert_string(1,s)
   1     return (s:gsub('[%-%.%+%[%]%(%)%$%^%%%?%*]','%%%1'))
     end

     --- split a string into a list of strings separated by a delimiter.
     -- @param s The input string
     -- @param re optional A Lua string pattern; defaults to '%s+'
     -- @param plain optional If truthy don't use Lua patterns
     -- @param n optional maximum number of elements (if there are more, the last will remain un-split)
     -- @return a list-like table
     -- @raise error if s is not a string
     -- @see splitv
***0 function utils.split(s,re,plain,n)
***0     utils.assert_string(1,s)
***0     local i1,ls = 1,{}
***0     if not re then re = '%s+' end
***0     if re == '' then return {s} end
         while true do
***0         local i2,i3 = find(s,re,i1,plain)
***0         if not i2 then
***0             local last = sub(s,i1)
***0             if last ~= '' then append(ls,last) end
***0             if #ls == 1 and ls[1] == '' then
***0                 return {}
                 else
***0                 return ls
                 end
             end
***0         append(ls,sub(s,i1,i2-1))
***0         if n and #ls == n then
***0             ls[#ls] = sub(s,i1)
***0             return ls
             end
***0         i1 = i3+1
         end
     end

     --- split a string into a number of return values.
     -- Identical to `split` but returns multiple sub-strings instead of
     -- a single list of sub-strings.
     -- @param s the string
     -- @param re A Lua string pattern; defaults to '%s+'
     -- @param plain don't use Lua patterns
     -- @param n optional maximum number of splits
     -- @return n values
     -- @usage first,next = splitv('user=jane=doe','=', false, 2)
     -- assert(first == "user")
     -- assert(next == "jane=doe")
     -- @see split
***0 function utils.splitv (s,re, plain, n)
***0     return _unpack(utils.split(s,re, plain, n))
     end


     --- Functional
     -- @section functional


     --- 'memoize' a function (cache returned value for next call).
     -- This is useful if you have a function which is relatively expensive,
     -- but you don't know in advance what values will be required, so
     -- building a table upfront is wasteful/impossible.
     -- @param func a function that takes exactly one argument (which later serves as the cache key) and returns a single value
     -- @return a function taking one argument and returning a single value either from the cache or by running the original input function
***0 function utils.memoize(func)
***0     local cache = {}
         return function(k)
***0         local res = cache[k]
***0         if res == nil then
***0             res = func(k)
***0             cache[k] = res
             end
***0         return res
         end
     end


     --- associate a function factory with a type.
     -- A function factory takes an object of the given type and
     -- returns a function for evaluating it
     -- @tab mt metatable
     -- @func fun a callable that returns a function
***0 function utils.add_function_factory (mt,fun)
***0     _function_factories[mt] = fun
     end

     local function _string_lambda(f)
***0     if f:find '^|' or f:find '_' then
***0         local args,body = f:match '|([^|]*)|(.+)'
***0         if f:find '_' then
***0             args = '_'
***0             body = f
             else
***0             if not args then return raise 'bad string lambda' end
             end
***0         local fstr = 'return function('..args..') return '..body..' end'
***0         local fn,err = utils.load(fstr)
***0         if not fn then return raise(err) end
***0         fn = fn()
***0         return fn
         else
***0         return raise 'not a string lambda'
         end
     end


     --- an anonymous function as a string. This string is either of the form
     -- '|args| expression' or is a function of one argument, '_'
     -- @param lf function as a string
     -- @return a function
     -- @function utils.string_lambda
     -- @usage
     -- string_lambda '|x|x+1' (2) == 3
     -- string_lambda '_+1' (2) == 3
***0 utils.string_lambda = utils.memoize(_string_lambda)


     --- bind the first argument of the function to a value.
     -- @param fn a function of at least two values (may be an operator string)
     -- @param p a value
     -- @return a function such that f(x) is fn(p,x)
     -- @raise same as @{function_arg}
     -- @see func.bind1
     -- @usage local function f(msg, name)
     --   print(msg .. " " .. name)
     -- end
     --
     -- local hello = utils.bind1(f, "Hello")
     --
     -- print(hello("world"))     --> "Hello world"
     -- print(hello("sunshine"))  --> "Hello sunshine"
***0 function utils.bind1 (fn,p)
***0     fn = utils.function_arg(1,fn)
***0     return function(...) return fn(p,...) end
     end


     --- bind the second argument of the function to a value.
     -- @param fn a function of at least two values (may be an operator string)
     -- @param p a value
     -- @return a function such that f(x) is fn(x,p)
     -- @raise same as @{function_arg}
     -- @usage local function f(a, b, c)
     --   print(a .. " " .. b .. " " .. c)
     -- end
     --
     -- local hello = utils.bind1(f, "world")
     --
     -- print(hello("Hello", "!"))  --> "Hello world !"
     -- print(hello("Bye", "?"))    --> "Bye world ?"
***0 function utils.bind2 (fn,p)
***0     fn = utils.function_arg(1,fn)
***0     return function(x,...) return fn(x,p,...) end
     end




     --- Deprecation
     -- @section deprecation

     do
       -- the default implementation
       local deprecation_func = function(msg, trace)
***0     if trace then
***0       warn(msg, "\n", trace)  -- luacheck: ignore
         else
***0       warn(msg)  -- luacheck: ignore
         end
       end

       --- Sets a deprecation warning function.
       -- An application can override this function to support proper output of
       -- deprecation warnings. The warnings can be generated from libraries or
       -- functions by calling `utils.raise_deprecation`. The default function
       -- will write to the 'warn' system (introduced in Lua 5.4, or the compatibility
       -- function from the `compat` module for earlier versions).
       --
       -- Note: only applications should set/change this function, libraries should not.
       -- @param func a callback with signature: `function(msg, trace)` both arguments are strings, the latter being optional.
       -- @see utils.raise_deprecation
       -- @usage
       -- -- write to the Nginx logs with OpenResty
       -- utils.set_deprecation_func(function(msg, trace)
       --   ngx.log(ngx.WARN, msg, (trace and (" " .. trace) or nil))
       -- end)
       --
       -- -- disable deprecation warnings
       -- utils.set_deprecation_func()
***0   function utils.set_deprecation_func(func)
***0     if func == nil then
***0       deprecation_func = function() end
         else
***0       utils.assert_arg(1, func, "function")
***0       deprecation_func = func
         end
       end

       --- raises a deprecation warning.
       -- For options see the usage example below.
       --
       -- Note: the `opts.deprecated_after` field is the last version in which
       -- a feature or option was NOT YET deprecated! Because when writing the code it
       -- is quite often not known in what version the code will land. But the last
       -- released version is usually known.
       -- @param opts options table
       -- @see utils.set_deprecation_func
       -- @usage
       -- warn("@on")   -- enable Lua warnings, they are usually off by default
       --
       -- function stringx.islower(str)
       --   raise_deprecation {
       --     source = "Penlight " .. utils._VERSION,                   -- optional
       --     message = "function 'islower' was renamed to 'is_lower'", -- required
       --     version_removed = "2.0.0",                                -- optional
       --     deprecated_after = "1.2.3",                               -- optional
       --     no_trace = true,                                          -- optional
       --   }
       --   return stringx.is_lower(str)
       -- end
       -- -- output: "[Penlight 1.9.2] function 'islower' was renamed to 'is_lower' (deprecated after 1.2.3, scheduled for removal in 2.0.0)"
***0   function utils.raise_deprecation(opts)
***0     utils.assert_arg(1, opts, "table")
***0     if type(opts.message) ~= "string" then
***0       error("field 'message' of the options table must be a string", 2)
         end
         local trace
***0     if not opts.no_trace then
***0       trace = debug.traceback("", 2):match("[\n%s]*(.-)$")
         end
         local msg
***0     if opts.deprecated_after and opts.version_removed then
***0       msg = (" (deprecated after %s, scheduled for removal in %s)"):format(
***0         tostring(opts.deprecated_after), tostring(opts.version_removed))
***0     elseif opts.deprecated_after then
***0       msg = (" (deprecated after %s)"):format(tostring(opts.deprecated_after))
***0     elseif opts.version_removed then
***0       msg = (" (scheduled for removal in %s)"):format(tostring(opts.version_removed))
         else
***0       msg = ""
         end

***0     msg = opts.message .. msg

***0     if opts.source then
***0       msg = "[" .. opts.source .."] " .. msg
         else
***0       if msg:sub(1,1) == "@" then
             -- in Lua 5.4 "@" prefixed messages are control messages to the warn system
***0         error("message cannot start with '@'", 2)
           end
         end

***0     deprecation_func(msg, trace)
       end

     end


***0 return utils



==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/say/init.lua
==============================================================================
***0 local unpack = table.unpack or unpack

***0 local registry = { }
     local current_namespace
     local fallback_namespace

***0 local s = {

       _COPYRIGHT   = "Copyright (c) 2012 Olivine Labs, LLC.",
       _DESCRIPTION = "A simple string key/value store for i18n or any other case where you want namespaced strings.",
       _VERSION     = "Say 1.3",

       set_namespace = function(self, namespace)
   1     current_namespace = namespace
   1     if not registry[current_namespace] then
***0       registry[current_namespace] = {}
         end
       end,

       set_fallback = function(self, namespace)
***0     fallback_namespace = namespace
***0     if not registry[fallback_namespace] then
***0       registry[fallback_namespace] = {}
         end
       end,

       set = function(self, key, value)
  19     registry[current_namespace][key] = value
       end
     }

***0 local __meta = {
       __call = function(self, key, vars)
***0     if vars ~= nil and type(vars) ~= "table" then
***0       error(("expected parameter table to be a table, got '%s'"):format(type(vars)), 2)
         end
***0     vars = vars or {}
***0     vars.n = math.max((vars.n or 0), #vars)

***0     local str = registry[current_namespace][key] or registry[fallback_namespace][key]

***0     if str == nil then
***0       return nil
         end
***0     str = tostring(str)
***0     local strings = {}

***0     for i = 1, vars.n or #vars do
***0       table.insert(strings, tostring(vars[i]))
         end

***0     return #strings > 0 and str:format(unpack(strings)) or str
       end,

       __index = function(self, key)
***0     return registry[key]
       end
     }

***0 s:set_fallback('en')
***0 s:set_namespace('en')

***0 s._registry = registry

***0 return setmetatable(s, __meta)

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/vusted/run.lua
==============================================================================
     return function()
       -- HACK: for wipe out "$@" arg buffer
***0   vim.cmd("silent! %bwipeout!")

       -- for loading test target
***0   vim.o.runtimepath = vim.fn.getcwd() .. "," .. vim.o.runtimepath

***0   local argv = vim.fn.argv()
       ---@cast argv string[]

       -- NOTICE: replace global arg
***0   arg = argv
***0   vim.cmd("%argdelete")

***0   if vim.tbl_contains(arg, "--version") then
***0     local version = _VERSION:sub(5)
***0     local package_version = vim.fn.system("luarocks --lua-version=" .. version .. " show vusted --mversion")
***0     print(package_version)
***0     os.exit(0)
       end

***0   if os.getenv("LOCAL_LUA_DEBUGGER_VSCODE") == "1" then
***0     require("lldebugger").start()
       end

***0   local runner = require("busted.runner")
***0   local ok, result = pcall(runner, { standalone = false, output = "vusted.default" })

       -- NOTICE: place after calling busted.runner to use patched os.exit when using --coverage
   1   local exit = os.exit
   1   if os.getenv("VUSTED_DISABLE_EXIT") then
***0     exit = function() end
***0     require("busted.compatibility").exit = exit -- HACK
       end

   1   local code = 0
   1   if not ok then
***0     print(result .. "\n")
***0     code = 1
       end
   1   exit(code)
     end

==============================================================================
Summary
==============================================================================

File                                                                                                               Hits Missed Coverage
---------------------------------------------------------------------------------------------------------------------------------------
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/block.lua                         39   56     41.05%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/context.lua                       37   45     45.12%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/core.lua                          47   138    25.41%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/environment.lua                   6    15     28.57%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/execute.lua                       19   21     47.50%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/init.lua                          5    74     6.33%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/languages/en.lua                  27   0      100.00%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/luajit.lua                        13   17     43.33%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/modules/files/lua.lua             7    4      63.64%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/modules/files/moonscript.lua      6    46     11.54%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/modules/filter_loader.lua         17   66     20.48%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/modules/output_handler_loader.lua 9    10     47.37%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/modules/test_file_loader.lua      43   11     79.63%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/outputHandlers/TAP.lua            23   41     35.94%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/outputHandlers/base.lua           29   65     30.85%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/outputHandlers/vusted/default.lua 18   29     38.30%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/runner.lua                        57   76     42.86%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/status.lua                        12   5      70.59%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/busted/utils.lua                         11   10     52.38%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/luassert/assert.lua                      2    78     2.50%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/mediator.lua                             39   26     60.00%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/pl/List.lua                              62   156    28.44%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/pl/class.lua                             20   82     19.61%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/pl/dir.lua                               65   188    25.69%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/pl/path.lua                              33   225    12.79%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/pl/tablex.lua                            27   377    6.68%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/pl/types.lua                             5    57     8.06%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/pl/utils.lua                             9    292    2.99%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/say/init.lua                             3    25     10.71%
/home/runner/work/code-stats.nvim/code-stats.nvim/.luarocks/share/lua/5.1/vusted/run.lua                           5    18     21.74%
---------------------------------------------------------------------------------------------------------------------------------------
Total                                                                                                              695  2253   23.58%
