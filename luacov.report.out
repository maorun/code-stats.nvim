==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/api.lua
==============================================================================
   2 local curl = require("plenary.curl")
   2 local pulse = require("maorun.code-stats.pulse")
   2 local cs_config = require("maorun.code-stats.config")
   2 local logging = require("maorun.code-stats.logging")

   2 local error_message = ""
   2 local is_vim_leaving = false

     local function requestToApi(body)
***0 	local url = cs_config.config.api_url
***0 	local full_url = url .. "api/my/pulses/"

***0 	logging.debug("Attempting API request to " .. full_url)

***0 	return curl.request({
     		url = full_url,
     		method = "POST",
***0 		headers = {
     			["X-API-Token"] = cs_config.config.api_key,
     			["Content-Type"] = "application/json",
     			["Accept"] = "application/json",
     		},
     		body = body,
     		on_error = function(data)
***0 			local error_details = data.message or "Unknown network error"
***0 			error_message = "Unable to sync with Code::Stats server: " .. error_details
***0 			logging.log_api_request(full_url, "POST", false, error_details)

     			-- If we're leaving vim and there's an error, persist the XP data
***0 			if is_vim_leaving then
***0 				pulse.save()
***0 				logging.warn("XP data persisted due to API error during vim exit")
     			end
     		end,
     		callback = function(response)
***0 			if response.status >= 200 and response.status < 300 then
***0 				error_message = ""
***0 				pulse.reset()
***0 				logging.log_api_request(full_url, "POST", true)
***0 				logging.info("XP data successfully sent to Code::Stats")
     			else
***0 				error_message = "Code::Stats server error (HTTP " .. response.status .. ")"
***0 				logging.log_api_request(full_url, "POST", false, "HTTP " .. response.status)
     			end
     		end,
     	})
     end

     local function pulseSend()
***0 	logging.debug("Starting pulse send operation")

     	-- Check if config is initialized by checking essential string fields
***0 	local config_values = {
***0 		cs_config.config.status_prefix,
***0 		cs_config.config.api_url,
***0 		cs_config.config.api_key,
     	}
***0 	if string.len(table.concat(config_values)) == 0 then
***0 		error_message = "Code::Stats plugin not properly configured"
***0 		logging.error("Plugin configuration incomplete - missing essential settings")
***0 		return
     	end

***0 	local url = cs_config.config.api_url
***0 	if string.len(url) == 0 then
***0 		error_message = "Code::Stats API URL not configured"
***0 		logging.error("Missing API URL configuration")
***0 		return
     	end

***0 	if string.len(cs_config.config.api_key) == 0 then
***0 		error_message = "Code::Stats API key not configured"
***0 		logging.error("Missing API key configuration")
***0 		return
     	end

     	-- If there was an error message set by previous checks, clear it if we proceed
***0 	error_message = ""

***0 	local languages = vim.fn.map(pulse.xps, function(language, xp)
***0 		if xp > 0 then
***0 			return '{"language": "' .. language .. '", "xp": ' .. xp .. "}"
     		else
***0 			return ""
     		end
     	end)

***0 	local xps = table.concat(vim.tbl_values(languages), ",")

***0 	if string.len(xps) > 0 then
***0 		local timestamp = os.date("%Y-%m-%dT%X%z")
***0 		local payload = '{ "coded_at": "' .. timestamp .. '", "xps": [ ' .. xps .. " ] }"
***0 		logging.info("Sending XP data: " .. xps)
***0 		requestToApi(payload)
***0 	elseif is_vim_leaving then
     		-- If we're leaving vim but have no XP to send, still clean up any persistence file
***0 		pulse.reset()
***0 		logging.info("No XP to send on vim exit, cleaning up persistence")
     	else
***0 		logging.debug("No XP data to send")
     	end
     end

     local function pulseSendOnExit()
***0 	logging.info("Performing final pulse send on vim exit")
***0 	is_vim_leaving = true
***0 	pulseSend()
***0 	is_vim_leaving = false
     end

     local function get_error()
   8 	return error_message
     end

   2 return {
   2 	pulseSend = pulseSend,
   2 	pulseSendOnExit = pulseSendOnExit,
   2 	requestToApi = requestToApi,
   2 	get_error = get_error,
   2 }

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/config.lua
==============================================================================
   6 local defaults = {
     	status_prefix = "C:S ",
     	api_url = "https://codestats.net/",
     	api_key = "",
   6 	ignored_filetypes = {},
   6 	logging = {
     		enabled = false,
     		level = "INFO", -- ERROR, WARN, INFO, DEBUG
     		file_path = nil, -- Will default to vim.fn.stdpath("data") .. "/code-stats.log" if not set
   6 	},
     }
   6 local config = defaults

   6 local logging = require("maorun.code-stats.logging")

   6 local M = {
  12 	config = vim.deepcopy(defaults),
     }

   6 function M.setup(user_config)
  13 	local globalConfig = {}
  13 	if vim.g.codestats_api_key then
***0 		globalConfig.api_key = vim.g.codestats_api_key
     	end
  26 	config = vim.tbl_deep_extend("force", defaults, user_config or {}, globalConfig)
  13 	M.config = config

     	-- Configure logging based on config
  13 	local log_config = {
  13 		enabled = config.logging.enabled,
  13 		file_path = config.logging.file_path,
     	}

     	-- Convert string level to number
  13 	if type(config.logging.level) == "string" then
  13 		local level_map = {
  13 			ERROR = logging.levels.ERROR,
  13 			WARN = logging.levels.WARN,
  13 			INFO = logging.levels.INFO,
  13 			DEBUG = logging.levels.DEBUG,
     		}
  13 		log_config.level = level_map[config.logging.level] or logging.levels.INFO
     	else
***0 		log_config.level = config.logging.level
     	end

  13 	logging.setup(log_config)
  13 	logging.log_config("Plugin configured with logging " .. (config.logging.enabled and "enabled" or "disabled"))

  13 	return config
     end

   6 return M

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/events.lua
==============================================================================
   2 local lang_detection = require("maorun.code-stats.language-detection")
   2 local logging = require("maorun.code-stats.logging")

     local function setup_autocommands(add_xp_callback, pulse_send_callback, pulse_send_on_exit_callback)
   8 	logging.log_init("Setting up autocommands for XP tracking")
   8 	local group = vim.api.nvim_create_augroup("codestats_track", { clear = true })

  16 	vim.api.nvim_create_autocmd({ "InsertCharPre", "TextChanged" }, {
   8 		group = group,
     		pattern = "*",
     		callback = function()
***0 			if add_xp_callback then
***0 				local detected_lang = lang_detection.detect_language()
***0 				add_xp_callback(detected_lang)
     			end
     		end,
     	})

  16 	vim.api.nvim_create_autocmd("VimLeavePre", {
   8 		group = group,
     		pattern = "*",
     		callback = function()
***0 			if pulse_send_on_exit_callback then
***0 				pulse_send_on_exit_callback()
     			end
     		end,
     	})

  16 	vim.api.nvim_create_autocmd({ "BufWrite", "BufLeave" }, {
   8 		group = group,
     		pattern = "*",
     		callback = function()
***0 			if pulse_send_callback then
***0 				pulse_send_callback()
     			end
     		end,
     	})

   8 	logging.log_init("Autocommands configured successfully")
     end

   2 return {
   2 	setup_autocommands = setup_autocommands,
   2 }

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/init.lua
==============================================================================
   8 local pulse = require("maorun.code-stats.pulse")
   8 local cs_config = require("maorun.code-stats.config")
   8 local api = require("maorun.code-stats.api")
   8 local events = require("maorun.code-stats.events")
   8 local lang_detection = require("maorun.code-stats.language-detection")
   8 local logging = require("maorun.code-stats.logging")

     -- Load any persisted XP data from previous sessions
   8 logging.log_init("Loading persisted XP data")
   8 pulse.load()

     -- The local 'error' variable has been removed. Errors are now primarily managed in api.lua.

     local function currentXp()
     	-- currentXp now relies on M.getError() which gets its value from api.get_error()
***0 	if string.len(api.get_error()) > 0 then
***0 		return cs_config.config.status_prefix .. "ERR"
     	end

***0 	local detected_lang = lang_detection.detect_language()
***0 	return cs_config.config.status_prefix .. pulse.getXp(detected_lang)
     end

     -- Get formatted XP information for the current language
     local function getCurrentLanguageXP()
   3 	if string.len(api.get_error()) > 0 then
***0 		return "Error: " .. api.get_error()
     	end

   1 	local detected_lang = lang_detection.detect_language()
   1 	local xp = pulse.getXp(detected_lang)
   1 	return string.format("Language: %s, XP: %d", detected_lang or "unknown", xp)
     end

     -- Get formatted XP information for all tracked languages
     local function getAllLanguagesXP()
   9 	if string.len(api.get_error()) > 0 then
***0 		return "Error: " .. api.get_error()
     	end

   3 	local result = "Tracked languages and XP:\n"
   3 	local languages = {}

     	-- Collect all languages with XP > 0
   9 	for lang, xp in pairs(pulse.xps) do
   6 		if xp > 0 then
   6 			table.insert(languages, { lang = lang, xp = xp })
     		end
     	end

     	-- Sort by XP descending
   6 	table.sort(languages, function(a, b)
   6 		return a.xp > b.xp
     	end)

   3 	if #languages == 0 then
   1 		result = result .. "  No XP tracked yet"
     	else
   8 		for _, entry in ipairs(languages) do
   6 			result = result .. string.format("  %s: %d XP\n", entry.lang, entry.xp)
     		end
     		-- Remove trailing newline
   4 		result = result:sub(1, -2)
     	end

   3 	return result
     end

     -- Get formatted XP information for a specific language
     local function getLanguageXP(language)
  12 	if string.len(api.get_error()) > 0 then
***0 		return "Error: " .. api.get_error()
     	end

   4 	if not language or language == "" then
   2 		return "Error: No language specified"
     	end

   2 	local xp = pulse.getXp(language)
   2 	return string.format("Language: %s, XP: %d", language, xp)
     end

   8 local M = {}

   8 function M.add(filetype)
     	-- Check if filetype is in ignored list
  23 	for _, ignored_type in ipairs(cs_config.config.ignored_filetypes) do
   8 		if filetype == ignored_type then
   3 			logging.debug("Skipping XP for ignored filetype: " .. filetype)
   3 			return -- Don't add XP for ignored filetypes
     		end
     	end
  15 	pulse.addXp(filetype, 1)
     end

   8 M.setup = cs_config.setup
   8 M.pulseSend = api.pulseSend
   8 M.currentXp = currentXp
     M.getError = function()
***0 	return api.get_error()
     end

     -- Public functions for user commands
   8 M.getCurrentLanguageXP = getCurrentLanguageXP
   8 M.getAllLanguagesXP = getAllLanguagesXP
   8 M.getLanguageXP = getLanguageXP

     -- Setup autocommands by passing the local add function, api.pulseSend, and api.pulseSendOnExit
   8 events.setup_autocommands(M.add, M.pulseSend, api.pulseSendOnExit)

     -- Create user commands
  16 vim.api.nvim_create_user_command("CodeStatsXP", function()
***0 	local info = getCurrentLanguageXP()
***0 	local error_msg = api.get_error()

***0 	if string.len(error_msg) > 0 then
***0 		vim.notify("Code::Stats Error: " .. error_msg, vim.log.levels.ERROR, { title = "Code::Stats" })
***0 		logging.error("User command CodeStatsXP failed: " .. error_msg)
     	else
***0 		vim.notify(info, vim.log.levels.INFO, { title = "Code::Stats" })
***0 		logging.debug("User command CodeStatsXP executed successfully")
     	end
   8 end, { desc = "Show XP for current language" })

  16 vim.api.nvim_create_user_command("CodeStatsAll", function()
***0 	local info = getAllLanguagesXP()
***0 	local error_msg = api.get_error()

***0 	if string.len(error_msg) > 0 then
***0 		vim.notify("Code::Stats Error: " .. error_msg, vim.log.levels.ERROR, { title = "Code::Stats" })
***0 		logging.error("User command CodeStatsAll failed: " .. error_msg)
     	else
***0 		vim.notify(info, vim.log.levels.INFO, { title = "Code::Stats" })
***0 		logging.debug("User command CodeStatsAll executed successfully")
     	end
   8 end, { desc = "Show XP for all tracked languages" })

  16 vim.api.nvim_create_user_command("CodeStatsLang", function(opts)
***0 	local info = getLanguageXP(opts.args)
***0 	local error_msg = api.get_error()

***0 	if string.len(error_msg) > 0 then
***0 		vim.notify("Code::Stats Error: " .. error_msg, vim.log.levels.ERROR, { title = "Code::Stats" })
***0 		logging.error("User command CodeStatsLang failed: " .. error_msg)
     	else
***0 		vim.notify(info, vim.log.levels.INFO, { title = "Code::Stats" })
***0 		logging.debug("User command CodeStatsLang executed for language: " .. (opts.args or "unknown"))
     	end
   8 end, {
     	nargs = 1,
     	desc = "Show XP for specific language",
     	complete = function()
     		-- Return list of tracked languages for completion
***0 		local languages = {}
***0 		for lang, xp in pairs(pulse.xps) do
***0 			if xp > 0 then
***0 				table.insert(languages, lang)
     			end
     		end
***0 		table.sort(languages)
***0 		return languages
     	end,
     })

     -- Add user command for managing logging
  16 vim.api.nvim_create_user_command("CodeStatsLog", function(opts)
***0 	local action = opts.args or ""

***0 	if action == "clear" then
***0 		logging.clear_log()
***0 		vim.notify("Code::Stats log file cleared", vim.log.levels.INFO, { title = "Code::Stats" })
***0 	elseif action == "path" then
***0 		local log_path = logging.get_log_file()
***0 		if log_path and logging.is_enabled() then
***0 			vim.notify("Log file: " .. log_path, vim.log.levels.INFO, { title = "Code::Stats" })
     		else
***0 			vim.notify("Logging is disabled", vim.log.levels.WARN, { title = "Code::Stats" })
     		end
***0 	elseif action == "status" then
***0 		local status = logging.is_enabled() and "enabled" or "disabled"
***0 		local log_path = logging.get_log_file() or "not set"
***0 		vim.notify(
***0 			"Logging is " .. status .. "\nLog file: " .. log_path,
***0 			vim.log.levels.INFO,
***0 			{ title = "Code::Stats" }
     		)
     	else
***0 		vim.notify("Usage: :CodeStatsLog [clear|path|status]", vim.log.levels.INFO, { title = "Code::Stats" })
     	end
   8 end, {
     	nargs = "?",
     	desc = "Manage Code::Stats logging (clear|path|status)",
     	complete = function()
***0 		return { "clear", "path", "status" }
     	end,
     })

     -- Add user command for manual XP synchronization
  16 vim.api.nvim_create_user_command("CodeStatsXpSend", function()
***0 	local error_msg = api.get_error()

     	-- Clear any previous error before sending
***0 	api.pulseSend()

     	-- Check for errors after sending
***0 	local new_error_msg = api.get_error()

***0 	if string.len(new_error_msg) > 0 then
***0 		vim.notify("Code::Stats Error: " .. new_error_msg, vim.log.levels.ERROR, { title = "Code::Stats" })
***0 		logging.error("User command CodeStatsXpSend failed: " .. new_error_msg)
     	else
***0 		vim.notify("XP data successfully sent to Code::Stats", vim.log.levels.INFO, { title = "Code::Stats" })
***0 		logging.debug("User command CodeStatsXpSend executed successfully")
     	end
   8 end, { desc = "Send all pending XP to Code::Stats immediately" })

   8 logging.log_init("User commands created successfully")
   8 logging.log_init("Code::Stats plugin initialization complete")

   8 return M

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/language-detection.lua
==============================================================================
  11 local M = {}

     -- Get the current cursor position
     local function get_cursor_position()
   5 	local cursor = vim.api.nvim_win_get_cursor(0)
   5 	return cursor[1] - 1, cursor[2] -- Convert to 0-indexed for treesitter
     end

     -- Attempt to detect language using treesitter language injection
     local function detect_language_at_cursor()
   7 	local base_filetype = vim.bo.filetype

     	-- Try to get any treesitter parser for the buffer
   7 	local has_parser, parser = pcall(vim.treesitter.get_parser, 0)
   7 	if not has_parser or not parser then
     		-- Fallback to original filetype if no treesitter parser
   2 		return base_filetype
     	end

   5 	local line, col = get_cursor_position()

     	-- Try to get the language tree at the cursor position
     	-- This will automatically handle language injection (e.g., CSS in HTML, JS in HTML, etc.)
   5 	local lang_tree = parser:language_for_range({ line, col, line, col })
   5 	if lang_tree then
   2 		local lang = lang_tree:lang()
     		-- Return the detected language if it's different from the base filetype
   2 		if lang and lang ~= base_filetype then
   1 			return lang
     		end
     	end

     	-- If language injection doesn't provide a different language, try to get the
     	-- tree at cursor position and check if it's in a different parser context
   4 	local tree_for_range = parser:tree_for_range({ line, col, line, col }, { include_children = true })
   4 	if tree_for_range then
     		-- Get the root language of this tree
   1 		local tree_lang = tree_for_range:lang()
   1 		if tree_lang and tree_lang ~= base_filetype then
   1 			return tree_lang
     		end
     	end

     	-- Check if there are any child parsers (injected languages)
   3 	local children = parser:children()
   4 	for _, child_parser in pairs(children) do
   2 		local child_lang = child_parser:lang()
   2 		if child_lang then
     			-- Check if cursor is within this child parser's range
   2 			local child_trees = child_parser:trees()
   3 			for _, child_tree in ipairs(child_trees) do
   2 				local root = child_tree:root()
   2 				local start_row, start_col, end_row, end_col = root:range()

     				-- Check if cursor is within this child tree's range
   2 				if line >= start_row and line <= end_row then
   1 					if line == start_row and col < start_col then
     						-- Before start
   1 					elseif line == end_row and col > end_col then
     						-- After end
     					else
     						-- Within range
   1 						return child_lang
     					end
     				end
     			end
     		end
     	end

     	-- No injected language found, return base filetype
   2 	return base_filetype
     end

     -- Main function to detect the current language at cursor position
  11 function M.detect_language()
   7 	return detect_language_at_cursor()
     end

     -- Function to get supported embedded languages for a given filetype
     -- This is now more dynamic - it discovers available injected languages
  11 function M.get_supported_languages(filetype)
   3 	local languages = { filetype }

     	-- Try to get parser and check for injected languages
   3 	local has_parser, parser = pcall(vim.treesitter.get_parser, 0)
   3 	if has_parser and parser then
   2 		local children = parser:children()
   4 		for _, child_parser in pairs(children) do
   2 			local child_lang = child_parser:lang()
   2 			if child_lang and child_lang ~= filetype then
     				-- Add to supported languages if not already present
   2 				local found = false
   5 				for _, lang in ipairs(languages) do
   3 					if lang == child_lang then
***0 						found = true
     						break
     					end
     				end
   2 				if not found then
   2 					table.insert(languages, child_lang)
     				end
     			end
     		end
     	end

   3 	return languages
     end

  11 return M

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/logging.lua
==============================================================================
     -- Centralized logging system for Code::Stats plugin
     -- Supports optional file logging with configurable levels

  26 local M = {}

     -- Log levels
  26 M.levels = {
     	ERROR = 1,
     	WARN = 2,
     	INFO = 3,
     	DEBUG = 4,
  26 }

     -- Level names for output
  26 local level_names = {
  26 	[M.levels.ERROR] = "ERROR",
  26 	[M.levels.WARN] = "WARN",
  26 	[M.levels.INFO] = "INFO",
  26 	[M.levels.DEBUG] = "DEBUG",
     }

     -- Default configuration
  26 local config = {
     	enabled = false,
  26 	level = M.levels.INFO,
     	file_path = nil,
     }

     -- Configure logging
  26 function M.setup(user_config)
  21 	if user_config then
  42 		config = vim.tbl_deep_extend("force", config, user_config)
     	end

     	-- Set default log file path if logging is enabled but no path specified
  21 	if config.enabled and not config.file_path then
   1 		local data_dir = vim.fn.stdpath("data")
   1 		config.file_path = data_dir .. "/code-stats.log"
     	end
     end

     -- Get current timestamp for log entries
     local function get_timestamp()
   7 	return os.date("%Y-%m-%d %H:%M:%S")
     end

     -- Write log entry to file
     local function write_to_file(level, message)
 112 	if not config.enabled or not config.file_path then
 103 		return
     	end

   9 	if level > config.level then
   2 		return
     	end

   7 	local timestamp = get_timestamp()
   7 	local level_name = level_names[level] or "UNKNOWN"
   7 	local log_entry = string.format("[%s] [%s] %s\n", timestamp, level_name, message)

     	-- Try to write to log file
   7 	local file = io.open(config.file_path, "a")
   7 	if file then
   6 		file:write(log_entry)
   6 		file:close()
     	end
     end

     -- Log an error message
  26 function M.error(message)
   4 	write_to_file(M.levels.ERROR, message)
     end

     -- Log a warning message
  26 function M.warn(message)
   3 	write_to_file(M.levels.WARN, message)
     end

     -- Log an info message
  26 function M.info(message)
  92 	write_to_file(M.levels.INFO, message)
     end

     -- Log a debug message
  26 function M.debug(message)
  13 	write_to_file(M.levels.DEBUG, message)
     end

     -- Log API requests
  26 function M.log_api_request(url, method, success, error_msg)
   2 	local status = success and "SUCCESS" or "FAILED"
   2 	local msg = string.format("API %s %s - %s", method, url, status)
   2 	if error_msg then
   1 		msg = msg .. " - " .. error_msg
     	end

   2 	if success then
   2 		M.info(msg)
     	else
   1 		M.error(msg)
     	end
     end

     -- Log XP operations
  26 function M.log_xp_operation(operation, language, amount, total)
  25 	local msg = string.format("XP %s: %s +%d (total: %d)", operation, language, amount or 0, total or 0)
  25 	M.info(msg)
     end

     -- Log configuration operations
  26 function M.log_config(message)
  13 	M.info("CONFIG: " .. message)
     end

     -- Log plugin initialization
  26 function M.log_init(message)
  40 	M.info("INIT: " .. message)
     end

     -- Get current log file path
  26 function M.get_log_file()
   2 	return config.file_path
     end

     -- Check if logging is enabled
  26 function M.is_enabled()
   3 	return config.enabled
     end

     -- Clear log file
  26 function M.clear_log()
   1 	if config.enabled and config.file_path then
   1 		local file = io.open(config.file_path, "w")
   1 		if file then
   1 			file:close()
   1 			M.info("Log file cleared")
     		end
     	end
     end

  26 return M

==============================================================================
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/pulse.lua
==============================================================================
  16 local logging = require("maorun.code-stats.logging")

  16 local pulse = {
  16 	xps = {},
     }

     -- Get the path for persisting XP data
     local function get_persistence_path()
  19 	local data_dir = vim.fn.stdpath("data")
  19 	return data_dir .. "/code-stats-xp.json"
     end

     -- Save XP data to file (only if there are XP values > 0)
     pulse.save = function()
   1 	local has_xp = false
   1 	for _, xp in pairs(pulse.xps) do
   1 		if xp > 0 then
   1 			has_xp = true
   1 			break
     		end
     	end

   1 	if not has_xp then
     		-- Remove persistence file if no XP to save
***0 		local file_path = get_persistence_path()
***0 		local ok, err = pcall(vim.fn.delete, file_path)
***0 		if not ok then
***0 			logging.warn("Failed to delete empty persistence file: " .. err)
     		else
***0 			logging.debug("Removed empty persistence file")
     		end
***0 		return
     	end

   1 	local file_path = get_persistence_path()
   1 	local ok, data = pcall(vim.fn.json_encode, pulse.xps)
   1 	if not ok then
***0 		logging.error("Failed to encode XP data for persistence: " .. data)
***0 		return
     	end

   1 	local file, err = io.open(file_path, "w")
   1 	if not file then
***0 		logging.error("Failed to open persistence file for writing: " .. (err or "unknown error"))
***0 		return
     	end

   1 	local success, write_err = pcall(file.write, file, data)
   1 	file:close()

   1 	if not success then
***0 		logging.error("Failed to write XP data to persistence file: " .. write_err)
     	else
   1 		logging.info("XP data persisted to file: " .. file_path)
     	end
     end

     -- Load XP data from file and merge with current XP
     pulse.load = function()
   9 	local file_path = get_persistence_path()
   9 	local file, err = io.open(file_path, "r")
   9 	if not file then
   8 		if err and not err:match("No such file") then
***0 			logging.warn("Could not open persistence file: " .. err)
     		end
   8 		logging.debug("No persistence file found, starting fresh")
   8 		return -- No persisted data
     	end

   1 	local success, content = pcall(file.read, file, "*all")
   1 	file:close()

   1 	if not success then
***0 		logging.error("Failed to read persistence file: " .. content)
***0 		return
     	end

   1 	if content and content ~= "" then
   1 		local ok, loaded_xps = pcall(vim.fn.json_decode, content)
   1 		if not ok then
***0 			logging.error("Failed to parse persisted XP data: " .. loaded_xps)
     			-- Try to remove corrupted file
***0 			local delete_ok, delete_err = pcall(vim.fn.delete, file_path)
***0 			if not delete_ok then
***0 				logging.warn("Failed to remove corrupted persistence file: " .. delete_err)
     			end
***0 			return
     		end

   1 		if type(loaded_xps) == "table" then
     			-- Merge loaded XP with current XP
   1 			local merged_count = 0
   2 			for lang, xp in pairs(loaded_xps) do
   1 				if type(xp) == "number" and xp > 0 then
   1 					local old_xp = pulse.getXp(lang)
   1 					pulse.xps[lang] = old_xp + xp
   1 					merged_count = merged_count + 1
   1 					logging.debug("Merged " .. xp .. " XP for " .. lang .. " (total: " .. pulse.xps[lang] .. ")")
     				end
     			end
   1 			logging.info("Loaded and merged " .. merged_count .. " languages from persistence file")

     			-- Remove the persistence file after loading
   1 			local delete_ok, delete_err = pcall(vim.fn.delete, file_path)
   1 			if not delete_ok then
***0 				logging.warn("Failed to remove persistence file after loading: " .. delete_err)
     			end
     		else
***0 			logging.error("Invalid persistence file format - expected table, got " .. type(loaded_xps))
     		end
     	end
     end

     pulse.addXp = function(lang, amount)
  26 	if not lang or lang == "" then
***0 		logging.warn("Attempted to add XP to empty language")
***0 		return
     	end

  26 	if not amount or amount <= 0 then
   2 		logging.warn("Attempted to add invalid XP amount: " .. tostring(amount))
   2 		return
     	end

  24 	local old_xp = pulse.getXp(lang)
  24 	pulse.xps[lang] = old_xp + amount
  24 	logging.log_xp_operation("ADD", lang, amount, pulse.xps[lang])
     end

     pulse.getXp = function(lang)
  44 	if pulse.xps[lang] then
  16 		return pulse.xps[lang]
     	end
  28 	return 0
     end

     pulse.reset = function()
   9 	local lang_count = 0
  12 	for _ in pairs(pulse.xps) do
   3 		lang_count = lang_count + 1
     	end

   9 	pulse.xps = {}
   9 	logging.info("Reset XP data (" .. lang_count .. " languages cleared)")

     	-- Also remove persistence file when resetting
   9 	local file_path = get_persistence_path()
  10 	local ok, err = pcall(vim.fn.delete, file_path)
   9 	if not ok then
***0 		logging.warn("Failed to delete persistence file during reset: " .. err)
     	end
     end

  16 return pulse

==============================================================================
Summary
==============================================================================

File                                                                                           Hits Missed Coverage
-------------------------------------------------------------------------------------------------------------------
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/api.lua                13   55     19.12%
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/config.lua             27   2      93.10%
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/events.lua             14   7      66.67%
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/init.lua               58   61     48.74%
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/language-detection.lua 48   1      97.96%
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/logging.lua            62   0      100.00%
/home/runner/work/code-stats.nvim/code-stats.nvim/lua/maorun/code-stats/pulse.lua              62   24     72.09%
-------------------------------------------------------------------------------------------------------------------
Total                                                                                          284  150    65.44%
